import { Request, Response, NextFunction } from 'express';
import { SecureJWTAuth, AuthUser, LoginAttempt } from './secure-jwt';
import * as crypto from 'crypto';
import * as nodemailer from 'nodemailer';
import { RateLimiterMemory } from 'rate-limiter-flexible';

export interface UserData {
  id: string;
  email: string;
  name: string;
  password: string;
  roles: string[];
  permissions: string[];
  emailVerified: boolean;
  twoFactorEnabled: boolean;
  twoFactorSecret?: string;
  lastLogin?: Date;
  loginAttempts: number;
  lockedUntil?: Date;
  passwordChangedAt: Date;
  emailVerificationToken?: string;
  emailVerificationExpiry?: Date;
  passwordResetToken?: string;
  passwordResetExpiry?: Date;
  refreshTokens: string[];
  sessions: UserSession[];
  createdAt: Date;
  updatedAt: Date;
}

export interface UserSession {
  sessionId: string;
  deviceId?: string;
  deviceName?: string;
  ipAddress: string;
  userAgent: string;
  lastActivity: Date;
  createdAt: Date;
  isActive: boolean;
}

export interface SecurityConfig {
  maxLoginAttempts: number;
  lockoutDuration: number; // minutes
  passwordResetExpiry: number; // minutes
  emailVerificationExpiry: number; // hours
  maxSessions: number;
  requireEmailVerification: boolean;
  enableTwoFactor: boolean;
  enableAccountLockout: boolean;
  passwordHistory: number; // Number of previous passwords to remember
}

export interface EmailConfig {
  host: string;
  port: number;
  secure: boolean;
  auth: {
    user: string;
    pass: string;
  };
  from: string;
}

// Secure in-memory storage with encryption (replace with database in production)
class SecureUserStorage {
  private users = new Map<string, UserData>();
  private usersByEmail = new Map<string, string>(); // email -> userId mapping
  private sessions = new Map<string, UserSession[]>(); // userId -> sessions
  private loginAttempts = new Map<string, LoginAttempt[]>();
  private readonly encryptionKey: Buffer;
  
  constructor() {
    // Generate encryption key for sensitive data at rest
    this.encryptionKey = crypto.randomBytes(32);
  }
  
  private encrypt(text: string): string {
    // Generate a random IV for each encryption (best practice)
    const iv = crypto.randomBytes(16);

    // Use createCipheriv (not deprecated createCipher) with explicit IV
    // aes-256-gcm provides authenticated encryption (AEAD)
    const cipher = crypto.createCipheriv('aes-256-gcm', this.encryptionKey, iv);

    let encrypted = cipher.update(text, 'utf8', 'hex');
    encrypted += cipher.final('hex');

    // Get authentication tag for integrity verification
    const authTag = cipher.getAuthTag();

    // Return IV:authTag:ciphertext (all components needed for decryption)
    return iv.toString('hex') + ':' + authTag.toString('hex') + ':' + encrypted;
  }

  private decrypt(encryptedText: string): string {
    const parts = encryptedText.split(':');
    if (parts.length !== 3) {
      throw new Error('Invalid encrypted data format');
    }

    const iv = Buffer.from(parts[0], 'hex');
    const authTag = Buffer.from(parts[1], 'hex');
    const encrypted = parts[2];

    // Use createDecipheriv (not deprecated createDecipher) with explicit IV
    const decipher = crypto.createDecipheriv('aes-256-gcm', this.encryptionKey, iv);

    // Set authentication tag for integrity verification
    decipher.setAuthTag(authTag);

    let decrypted = decipher.update(encrypted, 'hex', 'utf8');
    decrypted += decipher.final('utf8');

    return decrypted;
  }
  
  async createUser(userData: Omit<UserData, 'id' | 'createdAt' | 'updatedAt' | 'refreshTokens' | 'sessions'>): Promise<UserData> {
    const userId = crypto.randomBytes(16).toString('hex');
    const now = new Date();
    
    const user: UserData = {
      ...userData,
      id: userId,
      refreshTokens: [],
      sessions: [],
      createdAt: now,
      updatedAt: now,
    };
    
    // Encrypt sensitive fields
    if (user.twoFactorSecret) {
      user.twoFactorSecret = this.encrypt(user.twoFactorSecret);
    }
    
    this.users.set(userId, user);
    this.usersByEmail.set(user.email.toLowerCase(), userId);
    
    return user;
  }
  
  async findUserById(userId: string): Promise<UserData | null> {
    const user = this.users.get(userId);
    if (!user) return null;
    
    // Decrypt sensitive fields
    const decryptedUser = { ...user };
    if (decryptedUser.twoFactorSecret) {
      decryptedUser.twoFactorSecret = this.decrypt(decryptedUser.twoFactorSecret);
    }
    
    return decryptedUser;
  }
  
  async findUserByEmail(email: string): Promise<UserData | null> {
    const userId = this.usersByEmail.get(email.toLowerCase());
    if (!userId) return null;
    
    return this.findUserById(userId);
  }
  
  async updateUser(userId: string, updates: Partial<UserData>): Promise<UserData | null> {
    const user = this.users.get(userId);
    if (!user) return null;
    
    // Encrypt sensitive fields in updates
    const encryptedUpdates = { ...updates };
    if (encryptedUpdates.twoFactorSecret) {
      encryptedUpdates.twoFactorSecret = this.encrypt(encryptedUpdates.twoFactorSecret);
    }
    
    const updatedUser = {\n      ...user,\n      ...encryptedUpdates,\n      updatedAt: new Date(),\n    };\n    \n    this.users.set(userId, updatedUser);\n    \n    // Update email mapping if email changed\n    if (updates.email && updates.email !== user.email) {\n      this.usersByEmail.delete(user.email.toLowerCase());\n      this.usersByEmail.set(updates.email.toLowerCase(), userId);\n    }\n    \n    return this.findUserById(userId); // Return decrypted version\n  }\n  \n  async deleteUser(userId: string): Promise<boolean> {\n    const user = this.users.get(userId);\n    if (!user) return false;\n    \n    this.users.delete(userId);\n    this.usersByEmail.delete(user.email.toLowerCase());\n    this.sessions.delete(userId);\n    this.loginAttempts.delete(userId);\n    \n    return true;\n  }\n  \n  async addSession(userId: string, session: UserSession): Promise<void> {\n    const sessions = this.sessions.get(userId) || [];\n    sessions.push(session);\n    this.sessions.set(userId, sessions);\n  }\n  \n  async removeSession(userId: string, sessionId: string): Promise<void> {\n    const sessions = this.sessions.get(userId) || [];\n    const updatedSessions = sessions.filter(s => s.sessionId !== sessionId);\n    this.sessions.set(userId, updatedSessions);\n  }\n  \n  async getUserSessions(userId: string): Promise<UserSession[]> {\n    return this.sessions.get(userId) || [];\n  }\n  \n  async recordLoginAttempt(attempt: LoginAttempt): Promise<void> {\n    const key = attempt.userId || attempt.email;\n    const attempts = this.loginAttempts.get(key) || [];\n    attempts.push(attempt);\n    \n    // Keep only last 50 attempts\n    if (attempts.length > 50) {\n      attempts.splice(0, attempts.length - 50);\n    }\n    \n    this.loginAttempts.set(key, attempts);\n  }\n  \n  async getRecentLoginAttempts(identifier: string, timeWindow: number): Promise<LoginAttempt[]> {\n    const attempts = this.loginAttempts.get(identifier) || [];\n    const cutoff = new Date(Date.now() - timeWindow);\n    return attempts.filter(attempt => attempt.timestamp >= cutoff);\n  }\n}\n\nexport class SecureAuthHandler {\n  private jwtAuth: SecureJWTAuth;\n  private userStorage: SecureUserStorage;\n  private config: SecurityConfig;\n  private emailConfig?: EmailConfig;\n  private emailTransporter?: nodemailer.Transporter;\n  private loginRateLimiter: RateLimiterMemory;\n  private registrationRateLimiter: RateLimiterMemory;\n  \n  constructor(\n    jwtAuth: SecureJWTAuth,\n    config: Partial<SecurityConfig> = {},\n    emailConfig?: EmailConfig\n  ) {\n    this.jwtAuth = jwtAuth;\n    this.userStorage = new SecureUserStorage();\n    this.emailConfig = emailConfig;\n    \n    this.config = {\n      maxLoginAttempts: 5,\n      lockoutDuration: 15, // 15 minutes\n      passwordResetExpiry: 60, // 1 hour\n      emailVerificationExpiry: 24, // 24 hours\n      maxSessions: 5,\n      requireEmailVerification: true,\n      enableTwoFactor: false,\n      enableAccountLockout: true,\n      passwordHistory: 5,\n      ...config,\n    };\n    \n    // Initialize email transporter if config provided\n    if (this.emailConfig) {\n      this.emailTransporter = nodemailer.createTransporter(this.emailConfig);\n    }\n    \n    // Initialize rate limiters\n    this.loginRateLimiter = new RateLimiterMemory({\n      points: this.config.maxLoginAttempts,\n      duration: this.config.lockoutDuration * 60, // Convert to seconds\n      blockDuration: this.config.lockoutDuration * 60,\n    });\n    \n    this.registrationRateLimiter = new RateLimiterMemory({\n      points: 3, // 3 registration attempts\n      duration: 3600, // per hour\n      blockDuration: 3600,\n    });\n  }\n  \n  /**\n   * Register new user with comprehensive security checks\n   */\n  async register(req: Request, res: Response): Promise<void> {\n    try {\n      // Rate limiting for registration\n      const clientIP = this.getClientIP(req);\n      try {\n        await this.registrationRateLimiter.consume(clientIP);\n      } catch (rateLimitError) {\n        return res.status(429).json({\n          success: false,\n          error: 'Too many registration attempts. Please try again later.',\n        });\n      }\n      \n      const { email, password, name, roles = ['user'] } = req.body;\n      \n      // Input validation\n      const validation = this.validateRegistrationInput({ email, password, name });\n      if (!validation.isValid) {\n        return res.status(400).json({\n          success: false,\n          error: 'Validation failed',\n          details: validation.errors,\n        });\n      }\n      \n      // Check if user already exists\n      const existingUser = await this.userStorage.findUserByEmail(email);\n      if (existingUser) {\n        // Don't reveal that user exists - security best practice\n        return res.status(400).json({\n          success: false,\n          error: 'Registration failed. Please try with different details.',\n        });\n      }\n      \n      // Hash password\n      const hashedPassword = await this.jwtAuth.hashPassword(password);\n      \n      // Generate verification token if email verification required\n      let emailVerificationToken: string | undefined;\n      let emailVerificationExpiry: Date | undefined;\n      \n      if (this.config.requireEmailVerification) {\n        emailVerificationToken = crypto.randomBytes(32).toString('hex');\n        emailVerificationExpiry = new Date(\n          Date.now() + this.config.emailVerificationExpiry * 60 * 60 * 1000\n        );\n      }\n      \n      // Create user\n      const userData: Omit<UserData, 'id' | 'createdAt' | 'updatedAt' | 'refreshTokens' | 'sessions'> = {\n        email: email.toLowerCase(),\n        name: name.trim(),\n        password: hashedPassword,\n        roles: this.sanitizeRoles(roles),\n        permissions: this.getPermissionsForRoles(roles),\n        emailVerified: !this.config.requireEmailVerification,\n        twoFactorEnabled: false,\n        loginAttempts: 0,\n        passwordChangedAt: new Date(),\n        emailVerificationToken,\n        emailVerificationExpiry,\n      };\n      \n      const user = await this.userStorage.createUser(userData);\n      \n      // Send verification email if required\n      if (this.config.requireEmailVerification && emailVerificationToken) {\n        await this.sendVerificationEmail(email, emailVerificationToken);\n      }\n      \n      // Log security event\n      this.jwtAuth.logSecurityEvent({\n        type: 'login',\n        userId: user.id,\n        email: user.email,\n        ipAddress: clientIP,\n        userAgent: req.headers['user-agent'],\n        details: { action: 'registration' },\n      });\n      \n      // Generate tokens if email verification not required\n      if (!this.config.requireEmailVerification) {\n        const sessionId = this.jwtAuth.generateSessionId();\n        const deviceInfo = {\n          deviceId: this.generateDeviceId(req),\n          ipAddress: clientIP,\n        };\n        \n        const authUser: AuthUser = this.mapToAuthUser(user);\n        const accessToken = await this.jwtAuth.generateAccessToken(authUser, sessionId, deviceInfo);\n        const refreshToken = await this.jwtAuth.generateRefreshToken(authUser, sessionId);\n        \n        // Store session\n        await this.createUserSession(user.id, sessionId, req);\n        \n        // Set secure cookies\n        this.setSecureTokenCookies(res, accessToken, refreshToken);\n        \n        return res.status(201).json({\n          success: true,\n          user: this.sanitizeUserForResponse(user),\n          tokens: {\n            accessToken,\n            refreshToken,\n          },\n        });\n      }\n      \n      res.status(201).json({\n        success: true,\n        message: 'Registration successful. Please check your email for verification.',\n        emailVerificationRequired: true,\n      });\n      \n    } catch (error) {\n      console.error('Registration error:', error);\n      res.status(500).json({\n        success: false,\n        error: 'Registration failed due to server error.',\n      });\n    }\n  }\n  \n  /**\n   * Secure login with comprehensive attack protection\n   */\n  async login(req: Request, res: Response): Promise<void> {\n    const clientIP = this.getClientIP(req);\n    const userAgent = req.headers['user-agent'] || 'unknown';\n    \n    try {\n      // Rate limiting\n      try {\n        await this.loginRateLimiter.consume(clientIP);\n      } catch (rateLimitError) {\n        return res.status(429).json({\n          success: false,\n          error: 'Too many login attempts. Please try again later.',\n        });\n      }\n      \n      const { email, password, twoFactorCode, deviceName } = req.body;\n      \n      // Input validation\n      if (!email || !password) {\n        return res.status(400).json({\n          success: false,\n          error: 'Email and password are required.',\n        });\n      }\n      \n      // Find user\n      const user = await this.userStorage.findUserByEmail(email);\n      \n      // Record login attempt\n      const loginAttempt: LoginAttempt = {\n        email: email.toLowerCase(),\n        userId: user?.id,\n        ipAddress: clientIP,\n        userAgent,\n        success: false,\n        timestamp: new Date(),\n      };\n      \n      if (!user) {\n        loginAttempt.failureReason = 'user_not_found';\n        await this.userStorage.recordLoginAttempt(loginAttempt);\n        \n        // Constant time delay to prevent user enumeration\n        await this.constantTimeDelay();\n        \n        return res.status(401).json({\n          success: false,\n          error: 'Invalid credentials.',\n        });\n      }\n      \n      // Check if account is locked\n      if (this.config.enableAccountLockout && user.lockedUntil && user.lockedUntil > new Date()) {\n        loginAttempt.failureReason = 'account_locked';\n        await this.userStorage.recordLoginAttempt(loginAttempt);\n        \n        const lockoutMinutes = Math.ceil((user.lockedUntil.getTime() - Date.now()) / (1000 * 60));\n        return res.status(423).json({\n          success: false,\n          error: `Account is locked. Try again in ${lockoutMinutes} minutes.`,\n        });\n      }\n      \n      // Verify password\n      const isPasswordValid = await this.jwtAuth.verifyPassword(password, user.password);\n      \n      if (!isPasswordValid) {\n        loginAttempt.failureReason = 'invalid_password';\n        await this.userStorage.recordLoginAttempt(loginAttempt);\n        \n        // Increment login attempts and potentially lock account\n        await this.handleFailedLogin(user);\n        \n        return res.status(401).json({\n          success: false,\n          error: 'Invalid credentials.',\n        });\n      }\n      \n      // Check email verification\n      if (this.config.requireEmailVerification && !user.emailVerified) {\n        loginAttempt.failureReason = 'email_not_verified';\n        await this.userStorage.recordLoginAttempt(loginAttempt);\n        \n        return res.status(403).json({\n          success: false,\n          error: 'Please verify your email address before logging in.',\n        });\n      }\n      \n      // Check two-factor authentication\n      if (user.twoFactorEnabled) {\n        if (!twoFactorCode) {\n          return res.status(200).json({\n            success: false,\n            error: 'Two-factor authentication code required.',\n            requiresTwoFactor: true,\n          });\n        }\n        \n        const isTwoFactorValid = await this.verifyTwoFactorCode(user.twoFactorSecret!, twoFactorCode);\n        if (!isTwoFactorValid) {\n          loginAttempt.failureReason = 'invalid_2fa';\n          await this.userStorage.recordLoginAttempt(loginAttempt);\n          \n          return res.status(401).json({\n            success: false,\n            error: 'Invalid two-factor authentication code.',\n          });\n        }\n      }\n      \n      // Successful login - reset login attempts\n      await this.userStorage.updateUser(user.id, {\n        loginAttempts: 0,\n        lockedUntil: undefined,\n        lastLogin: new Date(),\n      });\n      \n      loginAttempt.success = true;\n      await this.userStorage.recordLoginAttempt(loginAttempt);\n      \n      // Generate session and tokens\n      const sessionId = this.jwtAuth.generateSessionId();\n      const deviceInfo = {\n        deviceId: this.generateDeviceId(req),\n        ipAddress: clientIP,\n      };\n      \n      const authUser: AuthUser = this.mapToAuthUser(user);\n      const accessToken = await this.jwtAuth.generateAccessToken(authUser, sessionId, deviceInfo);\n      const refreshToken = await this.jwtAuth.generateRefreshToken(authUser, sessionId);\n      \n      // Store session\n      await this.createUserSession(user.id, sessionId, req, deviceName);\n      \n      // Set secure cookies\n      this.setSecureTokenCookies(res, accessToken, refreshToken);\n      \n      // Log security event\n      this.jwtAuth.logSecurityEvent({\n        type: 'login',\n        userId: user.id,\n        email: user.email,\n        ipAddress: clientIP,\n        userAgent,\n        details: { sessionId, deviceId: deviceInfo.deviceId },\n      });\n      \n      res.json({\n        success: true,\n        user: this.sanitizeUserForResponse(user),\n        tokens: {\n          accessToken,\n          refreshToken,\n        },\n      });\n      \n    } catch (error) {\n      console.error('Login error:', error);\n      res.status(500).json({\n        success: false,\n        error: 'Login failed due to server error.',\n      });\n    }\n  }\n  \n  /**\n   * Secure token refresh with rotation\n   */\n  async refreshTokens(req: Request, res: Response): Promise<void> {\n    try {\n      const { refreshToken } = req.body;\n      \n      if (!refreshToken) {\n        return res.status(400).json({\n          success: false,\n          error: 'Refresh token is required.',\n        });\n      }\n      \n      // Verify refresh token\n      const payload = await this.jwtAuth.verifyRefreshToken(refreshToken);\n      \n      if (!payload) {\n        return res.status(401).json({\n          success: false,\n          error: 'Invalid or expired refresh token.',\n        });\n      }\n      \n      // Get user\n      const user = await this.userStorage.findUserById(payload.sub);\n      if (!user) {\n        return res.status(401).json({\n          success: false,\n          error: 'User not found.',\n        });\n      }\n      \n      // Verify session exists\n      const sessions = await this.userStorage.getUserSessions(user.id);\n      const session = sessions.find(s => s.sessionId === payload.sessionId && s.isActive);\n      \n      if (!session) {\n        return res.status(401).json({\n          success: false,\n          error: 'Session not found or inactive.',\n        });\n      }\n      \n      // Revoke old refresh token\n      await this.jwtAuth.revokeToken(payload);\n      \n      // Generate new tokens\n      const newSessionId = this.jwtAuth.generateSessionId();\n      const deviceInfo = {\n        deviceId: session.deviceId,\n        ipAddress: this.getClientIP(req),\n      };\n      \n      const authUser: AuthUser = this.mapToAuthUser(user);\n      const newAccessToken = await this.jwtAuth.generateAccessToken(authUser, newSessionId, deviceInfo);\n      const newRefreshToken = await this.jwtAuth.generateRefreshToken(authUser, newSessionId);\n      \n      // Update session\n      session.sessionId = newSessionId;\n      session.lastActivity = new Date();\n      session.ipAddress = deviceInfo.ipAddress;\n      \n      // Set secure cookies\n      this.setSecureTokenCookies(res, newAccessToken, newRefreshToken);\n      \n      // Log security event\n      this.jwtAuth.logSecurityEvent({\n        type: 'token_refresh',\n        userId: user.id,\n        email: user.email,\n        ipAddress: deviceInfo.ipAddress,\n        userAgent: req.headers['user-agent'],\n        details: { oldSessionId: payload.sessionId, newSessionId },\n      });\n      \n      res.json({\n        success: true,\n        tokens: {\n          accessToken: newAccessToken,\n          refreshToken: newRefreshToken,\n        },\n      });\n      \n    } catch (error) {\n      console.error('Token refresh error:', error);\n      res.status(500).json({\n        success: false,\n        error: 'Token refresh failed.',\n      });\n    }\n  }\n  \n  /**\n   * Secure logout with token revocation\n   */\n  async logout(req: Request, res: Response): Promise<void> {\n    try {\n      const user = (req as any).user as AuthUser;\n      const tokenPayload = (req as any).tokenPayload;\n      const { logoutAllDevices = false } = req.body;\n      \n      if (!user || !tokenPayload) {\n        return res.status(401).json({\n          success: false,\n          error: 'Not authenticated.',\n        });\n      }\n      \n      // Revoke current token\n      await this.jwtAuth.revokeToken(tokenPayload);\n      \n      if (logoutAllDevices) {\n        // Revoke all sessions for user\n        const sessions = await this.userStorage.getUserSessions(user.id);\n        for (const session of sessions) {\n          session.isActive = false;\n        }\n      } else {\n        // Revoke only current session\n        await this.userStorage.removeSession(user.id, tokenPayload.sessionId);\n      }\n      \n      // Clear cookies\n      res.clearCookie('accessToken', {\n        httpOnly: true,\n        secure: process.env.NODE_ENV === 'production',\n        sameSite: 'strict',\n      });\n      \n      res.clearCookie('refreshToken', {\n        httpOnly: true,\n        secure: process.env.NODE_ENV === 'production',\n        sameSite: 'strict',\n      });\n      \n      // Log security event\n      this.jwtAuth.logSecurityEvent({\n        type: 'logout',\n        userId: user.id,\n        email: user.email,\n        ipAddress: this.getClientIP(req),\n        userAgent: req.headers['user-agent'],\n        details: { logoutAllDevices, sessionId: tokenPayload.sessionId },\n      });\n      \n      res.json({\n        success: true,\n        message: 'Logged out successfully.',\n      });\n      \n    } catch (error) {\n      console.error('Logout error:', error);\n      res.status(500).json({\n        success: false,\n        error: 'Logout failed.',\n      });\n    }\n  }\n  \n  /**\n   * Password reset request with secure token generation\n   */\n  async requestPasswordReset(req: Request, res: Response): Promise<void> {\n    try {\n      const { email } = req.body;\n      \n      if (!email || !this.isValidEmail(email)) {\n        return res.status(400).json({\n          success: false,\n          error: 'Valid email address is required.',\n        });\n      }\n      \n      // Rate limiting for password reset requests\n      const clientIP = this.getClientIP(req);\n      try {\n        await this.registrationRateLimiter.consume(`reset_${clientIP}`);\n      } catch (rateLimitError) {\n        return res.status(429).json({\n          success: false,\n          error: 'Too many password reset attempts. Please try again later.',\n        });\n      }\n      \n      const user = await this.userStorage.findUserByEmail(email);\n      \n      // Always return success to prevent user enumeration\n      if (!user) {\n        // Simulate processing time\n        await this.constantTimeDelay();\n        return res.json({\n          success: true,\n          message: 'If an account with this email exists, a password reset link has been sent.',\n        });\n      }\n      \n      // Generate secure reset token\n      const resetToken = crypto.randomBytes(32).toString('hex');\n      const resetExpiry = new Date(Date.now() + this.config.passwordResetExpiry * 60 * 1000);\n      \n      // Update user with reset token\n      await this.userStorage.updateUser(user.id, {\n        passwordResetToken: resetToken,\n        passwordResetExpiry: resetExpiry,\n      });\n      \n      // Send password reset email\n      await this.sendPasswordResetEmail(user.email, resetToken);\n      \n      // Log security event\n      this.jwtAuth.logSecurityEvent({\n        type: 'suspicious_activity',\n        userId: user.id,\n        email: user.email,\n        ipAddress: clientIP,\n        userAgent: req.headers['user-agent'],\n        details: { action: 'password_reset_requested' },\n      });\n      \n      res.json({\n        success: true,\n        message: 'If an account with this email exists, a password reset link has been sent.',\n      });\n      \n    } catch (error) {\n      console.error('Password reset request error:', error);\n      res.status(500).json({\n        success: false,\n        error: 'Password reset request failed.',\n      });\n    }\n  }\n  \n  /**\n   * Reset password with token validation\n   */\n  async resetPassword(req: Request, res: Response): Promise<void> {\n    try {\n      const { token, newPassword } = req.body;\n      \n      if (!token || !newPassword) {\n        return res.status(400).json({\n          success: false,\n          error: 'Reset token and new password are required.',\n        });\n      }\n      \n      // Find user by reset token\n      const users = await this.getAllUsers(); // This would be a proper query in production\n      const user = users.find(u => \n        u.passwordResetToken === token && \n        u.passwordResetExpiry && \n        u.passwordResetExpiry > new Date()\n      );\n      \n      if (!user) {\n        return res.status(400).json({\n          success: false,\n          error: 'Invalid or expired reset token.',\n        });\n      }\n      \n      // Hash new password\n      const hashedPassword = await this.jwtAuth.hashPassword(newPassword);\n      \n      // Update user password and clear reset token\n      await this.userStorage.updateUser(user.id, {\n        password: hashedPassword,\n        passwordResetToken: undefined,\n        passwordResetExpiry: undefined,\n        passwordChangedAt: new Date(),\n        loginAttempts: 0, // Reset login attempts\n        lockedUntil: undefined, // Unlock account if locked\n      });\n      \n      // Revoke all active sessions for security\n      const sessions = await this.userStorage.getUserSessions(user.id);\n      for (const session of sessions) {\n        session.isActive = false;\n      }\n      \n      // Log security event\n      this.jwtAuth.logSecurityEvent({\n        type: 'suspicious_activity',\n        userId: user.id,\n        email: user.email,\n        ipAddress: this.getClientIP(req),\n        userAgent: req.headers['user-agent'],\n        details: { action: 'password_reset_completed' },\n      });\n      \n      res.json({\n        success: true,\n        message: 'Password has been reset successfully. Please log in with your new password.',\n      });\n      \n    } catch (error) {\n      console.error('Password reset error:', error);\n      res.status(500).json({\n        success: false,\n        error: 'Password reset failed.',\n      });\n    }\n  }\n  \n  /**\n   * Get current user information\n   */\n  async getCurrentUser(req: Request, res: Response): Promise<void> {\n    try {\n      const user = (req as any).user as AuthUser;\n      \n      if (!user) {\n        return res.status(401).json({\n          success: false,\n          error: 'Not authenticated.',\n        });\n      }\n      \n      const fullUser = await this.userStorage.findUserById(user.id);\n      if (!fullUser) {\n        return res.status(404).json({\n          success: false,\n          error: 'User not found.',\n        });\n      }\n      \n      const sessions = await this.userStorage.getUserSessions(user.id);\n      \n      res.json({\n        success: true,\n        user: {\n          ...this.sanitizeUserForResponse(fullUser),\n          activeSessions: sessions.filter(s => s.isActive).length,\n        },\n      });\n      \n    } catch (error) {\n      console.error('Get current user error:', error);\n      res.status(500).json({\n        success: false,\n        error: 'Failed to get user information.',\n      });\n    }\n  }\n  \n  // Helper methods\n  \n  private validateRegistrationInput(input: { email: string; password: string; name: string }): { isValid: boolean; errors: string[] } {\n    const errors: string[] = [];\n    \n    if (!this.isValidEmail(input.email)) {\n      errors.push('Invalid email format');\n    }\n    \n    if (!input.name || input.name.trim().length < 2) {\n      errors.push('Name must be at least 2 characters long');\n    }\n    \n    if (input.name && input.name.length > 100) {\n      errors.push('Name must be less than 100 characters');\n    }\n    \n    // Password validation is handled by SecureJWTAuth.hashPassword\n    \n    return {\n      isValid: errors.length === 0,\n      errors,\n    };\n  }\n  \n  private isValidEmail(email: string): boolean {\n    const emailRegex = /^[^\\s@]+@[^\\s@]+\\.[^\\s@]+$/;\n    return emailRegex.test(email) && email.length <= 254;\n  }\n  \n  private sanitizeRoles(roles: string[]): string[] {\n    const allowedRoles = ['user', 'editor', 'admin'];\n    return roles.filter(role => allowedRoles.includes(role));\n  }\n  \n  private getPermissionsForRoles(roles: string[]): string[] {\n    const permissions: string[] = [];\n    \n    for (const role of roles) {\n      switch (role) {\n        case 'admin':\n          permissions.push('read', 'write', 'delete', 'admin', 'user_management');\n          break;\n        case 'editor':\n          permissions.push('read', 'write', 'upload');\n          break;\n        case 'user':\n          permissions.push('read');\n          break;\n      }\n    }\n    \n    return [...new Set(permissions)];\n  }\n  \n  private mapToAuthUser(user: UserData): AuthUser {\n    return {\n      id: user.id,\n      email: user.email,\n      name: user.name,\n      roles: user.roles,\n      permissions: user.permissions,\n      emailVerified: user.emailVerified,\n      twoFactorEnabled: user.twoFactorEnabled,\n      lastLogin: user.lastLogin || new Date(),\n      loginAttempts: user.loginAttempts,\n      lockedUntil: user.lockedUntil,\n      passwordChangedAt: user.passwordChangedAt,\n    };\n  }\n  \n  private sanitizeUserForResponse(user: UserData) {\n    return {\n      id: user.id,\n      email: user.email,\n      name: user.name,\n      roles: user.roles,\n      permissions: user.permissions,\n      emailVerified: user.emailVerified,\n      twoFactorEnabled: user.twoFactorEnabled,\n      lastLogin: user.lastLogin,\n      createdAt: user.createdAt,\n    };\n  }\n  \n  private async handleFailedLogin(user: UserData): Promise<void> {\n    const newAttempts = user.loginAttempts + 1;\n    const updates: Partial<UserData> = {\n      loginAttempts: newAttempts,\n    };\n    \n    if (this.config.enableAccountLockout && newAttempts >= this.config.maxLoginAttempts) {\n      updates.lockedUntil = new Date(Date.now() + this.config.lockoutDuration * 60 * 1000);\n    }\n    \n    await this.userStorage.updateUser(user.id, updates);\n  }\n  \n  private async createUserSession(userId: string, sessionId: string, req: Request, deviceName?: string): Promise<void> {\n    const session: UserSession = {\n      sessionId,\n      deviceId: this.generateDeviceId(req),\n      deviceName: deviceName || this.getDeviceName(req),\n      ipAddress: this.getClientIP(req),\n      userAgent: req.headers['user-agent'] || 'unknown',\n      lastActivity: new Date(),\n      createdAt: new Date(),\n      isActive: true,\n    };\n    \n    // Remove old sessions if max limit exceeded\n    const existingSessions = await this.userStorage.getUserSessions(userId);\n    const activeSessions = existingSessions.filter(s => s.isActive);\n    \n    if (activeSessions.length >= this.config.maxSessions) {\n      // Remove oldest session\n      const oldestSession = activeSessions.sort((a, b) => a.lastActivity.getTime() - b.lastActivity.getTime())[0];\n      await this.userStorage.removeSession(userId, oldestSession.sessionId);\n    }\n    \n    await this.userStorage.addSession(userId, session);\n  }\n  \n  private generateDeviceId(req: Request): string {\n    const userAgent = req.headers['user-agent'] || '';\n    const acceptLanguage = req.headers['accept-language'] || '';\n    const acceptEncoding = req.headers['accept-encoding'] || '';\n    \n    const deviceString = `${userAgent}:${acceptLanguage}:${acceptEncoding}`;\n    return crypto.createHash('sha256').update(deviceString).digest('hex').substring(0, 16);\n  }\n  \n  private getDeviceName(req: Request): string {\n    const userAgent = req.headers['user-agent'] || 'Unknown Device';\n    \n    if (userAgent.includes('Mobile')) return 'Mobile Device';\n    if (userAgent.includes('Tablet')) return 'Tablet';\n    if (userAgent.includes('Chrome')) return 'Chrome Browser';\n    if (userAgent.includes('Firefox')) return 'Firefox Browser';\n    if (userAgent.includes('Safari')) return 'Safari Browser';\n    if (userAgent.includes('Edge')) return 'Edge Browser';\n    \n    return 'Desktop Browser';\n  }\n  \n  private setSecureTokenCookies(res: Response, accessToken: string, refreshToken: string): void {\n    const isProduction = process.env.NODE_ENV === 'production';\n    \n    res.cookie('accessToken', accessToken, {\n      httpOnly: true,\n      secure: isProduction,\n      sameSite: 'strict',\n      maxAge: 15 * 60 * 1000, // 15 minutes\n    });\n    \n    res.cookie('refreshToken', refreshToken, {\n      httpOnly: true,\n      secure: isProduction,\n      sameSite: 'strict',\n      maxAge: 7 * 24 * 60 * 60 * 1000, // 7 days\n    });\n  }\n  \n  private getClientIP(req: Request): string {\n    return (\n      (req.headers['x-forwarded-for'] as string) ||\n      (req.headers['x-real-ip'] as string) ||\n      req.connection.remoteAddress ||\n      req.socket.remoteAddress ||\n      'unknown'\n    ).split(',')[0].trim();\n  }\n  \n  private async constantTimeDelay(): Promise<void> {\n    // Simulate bcrypt comparison time to prevent timing attacks\n    await new Promise(resolve => setTimeout(resolve, 100 + Math.random() * 50));\n  }\n  \n  private async verifyTwoFactorCode(secret: string, code: string): Promise<boolean> {\n    // This would integrate with a TOTP library like speakeasy\n    // For now, return true as placeholder\n    console.log('2FA verification not implemented yet');\n    return true;\n  }\n  \n  private async sendVerificationEmail(email: string, token: string): Promise<void> {\n    if (!this.emailTransporter) {\n      console.log(`Verification email would be sent to ${email} with token: ${token}`);\n      return;\n    }\n    \n    const verificationUrl = `${process.env.CLIENT_URL}/verify-email?token=${token}`;\n    \n    await this.emailTransporter.sendMail({\n      to: email,\n      subject: 'Verify your SightEdit account',\n      html: `\n        <h2>Welcome to SightEdit!</h2>\n        <p>Please click the link below to verify your email address:</p>\n        <a href=\"${verificationUrl}\" style=\"background: #007bff; color: white; padding: 10px 20px; text-decoration: none; border-radius: 5px;\">Verify Email</a>\n        <p>If you didn't create an account, please ignore this email.</p>\n        <p>This link expires in ${this.config.emailVerificationExpiry} hours.</p>\n      `,\n    });\n  }\n  \n  private async sendPasswordResetEmail(email: string, token: string): Promise<void> {\n    if (!this.emailTransporter) {\n      console.log(`Password reset email would be sent to ${email} with token: ${token}`);\n      return;\n    }\n    \n    const resetUrl = `${process.env.CLIENT_URL}/reset-password?token=${token}`;\n    \n    await this.emailTransporter.sendMail({\n      to: email,\n      subject: 'Reset your SightEdit password',\n      html: `\n        <h2>Password Reset Request</h2>\n        <p>You requested to reset your password. Click the link below to set a new password:</p>\n        <a href=\"${resetUrl}\" style=\"background: #dc3545; color: white; padding: 10px 20px; text-decoration: none; border-radius: 5px;\">Reset Password</a>\n        <p>If you didn't request this reset, please ignore this email.</p>\n        <p>This link expires in ${this.config.passwordResetExpiry} minutes.</p>\n      `,\n    });\n  }\n  \n  private async getAllUsers(): Promise<UserData[]> {\n    // This is a placeholder - in production this would be a proper database query\n    const users: UserData[] = [];\n    // Implementation would depend on the storage system\n    return users;\n  }\n  \n  // Middleware factory for authentication\n  createAuthMiddleware(options: {\n    required?: boolean;\n    roles?: string[];\n    permissions?: string[];\n    requireEmailVerified?: boolean;\n  } = {}) {\n    return this.jwtAuth.authenticate(options);\n  }\n}