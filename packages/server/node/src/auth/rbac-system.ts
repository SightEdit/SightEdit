import { Request, Response, NextFunction } from 'express';

export interface Permission {
  name: string;
  description: string;
  resource?: string;
  action: string;
  conditions?: PermissionCondition[];
}

export interface Role {
  name: string;
  description: string;
  permissions: string[];
  hierarchyLevel: number;
  isSystemRole: boolean;
  inheritsFrom?: string[];
}

export interface PermissionCondition {
  type: 'ownership' | 'time' | 'ip' | 'resource_state' | 'custom';
  operator: 'equals' | 'not_equals' | 'contains' | 'in' | 'not_in' | 'greater_than' | 'less_than' | 'between';
  value: any;
  field?: string;
}

export interface AccessContext {
  userId: string;
  userRoles: string[];
  userPermissions: string[];
  resource?: any;
  resourceId?: string;
  resourceType?: string;
  requestContext: {
    ip: string;
    userAgent: string;
    timestamp: Date;
    method: string;
    path: string;
  };
}

export interface AuthorizationResult {
  allowed: boolean;
  reason?: string;
  requiredPermissions?: string[];
  missingPermissions?: string[];
  conditionsEvaluated?: boolean;
  additionalContext?: Record<string, any>;
}

/**\n * Comprehensive Role-Based Access Control (RBAC) System\n * Implements hierarchical roles, conditional permissions, and resource-level access control\n */\nexport class RBACSystem {\n  private permissions = new Map<string, Permission>();\n  private roles = new Map<string, Role>();\n  private userRoleCache = new Map<string, { roles: string[]; cachedAt: Date }>();\n  private readonly CACHE_TTL = 300000; // 5 minutes\n  \n  constructor() {\n    this.initializeDefaultPermissions();\n    this.initializeDefaultRoles();\n  }\n  \n  /**\n   * Initialize default system permissions\n   */\n  private initializeDefaultPermissions(): void {\n    const defaultPermissions: Permission[] = [\n      // Content permissions\n      { name: 'content:read', description: 'Read content', resource: 'content', action: 'read' },\n      { name: 'content:write', description: 'Create and edit content', resource: 'content', action: 'write' },\n      { name: 'content:delete', description: 'Delete content', resource: 'content', action: 'delete' },\n      { name: 'content:publish', description: 'Publish content', resource: 'content', action: 'publish' },\n      \n      // File permissions\n      { name: 'file:upload', description: 'Upload files', resource: 'file', action: 'upload' },\n      { name: 'file:download', description: 'Download files', resource: 'file', action: 'download' },\n      { name: 'file:delete', description: 'Delete files', resource: 'file', action: 'delete' },\n      \n      // Schema permissions\n      { name: 'schema:read', description: 'Read schema definitions', resource: 'schema', action: 'read' },\n      { name: 'schema:write', description: 'Create and edit schemas', resource: 'schema', action: 'write' },\n      { name: 'schema:delete', description: 'Delete schemas', resource: 'schema', action: 'delete' },\n      \n      // User management permissions\n      { name: 'user:read', description: 'View user information', resource: 'user', action: 'read' },\n      { name: 'user:write', description: 'Create and edit users', resource: 'user', action: 'write' },\n      { name: 'user:delete', description: 'Delete users', resource: 'user', action: 'delete' },\n      { name: 'user:manage_roles', description: 'Assign and remove user roles', resource: 'user', action: 'manage_roles' },\n      \n      // System permissions\n      { name: 'system:admin', description: 'Full system administration', resource: 'system', action: 'admin' },\n      { name: 'system:logs', description: 'View system logs', resource: 'system', action: 'logs' },\n      { name: 'system:metrics', description: 'View system metrics', resource: 'system', action: 'metrics' },\n      { name: 'system:backup', description: 'Create and manage backups', resource: 'system', action: 'backup' },\n      \n      // API permissions\n      { name: 'api:batch', description: 'Perform batch operations', resource: 'api', action: 'batch' },\n      { name: 'api:webhooks', description: 'Manage webhooks', resource: 'api', action: 'webhooks' },\n    ];\n    \n    defaultPermissions.forEach(permission => {\n      this.permissions.set(permission.name, permission);\n    });\n  }\n  \n  /**\n   * Initialize default system roles with hierarchy\n   */\n  private initializeDefaultRoles(): void {\n    const defaultRoles: Role[] = [\n      {\n        name: 'viewer',\n        description: 'Read-only access to content',\n        permissions: ['content:read', 'file:download'],\n        hierarchyLevel: 1,\n        isSystemRole: true,\n      },\n      {\n        name: 'contributor',\n        description: 'Can create and edit content',\n        permissions: ['content:read', 'content:write', 'file:upload', 'file:download'],\n        hierarchyLevel: 2,\n        isSystemRole: true,\n        inheritsFrom: ['viewer'],\n      },\n      {\n        name: 'editor',\n        description: 'Can manage content and files',\n        permissions: [\n          'content:read', 'content:write', 'content:delete', 'content:publish',\n          'file:upload', 'file:download', 'file:delete',\n          'schema:read',\n          'api:batch'\n        ],\n        hierarchyLevel: 3,\n        isSystemRole: true,\n        inheritsFrom: ['contributor'],\n      },\n      {\n        name: 'moderator',\n        description: 'Can manage users and content with some restrictions',\n        permissions: [\n          'content:read', 'content:write', 'content:delete', 'content:publish',\n          'file:upload', 'file:download', 'file:delete',\n          'schema:read', 'schema:write',\n          'user:read', 'user:write',\n          'api:batch', 'system:logs'\n        ],\n        hierarchyLevel: 4,\n        isSystemRole: true,\n        inheritsFrom: ['editor'],\n      },\n      {\n        name: 'admin',\n        description: 'Full system administrator',\n        permissions: [\n          'content:read', 'content:write', 'content:delete', 'content:publish',\n          'file:upload', 'file:download', 'file:delete',\n          'schema:read', 'schema:write', 'schema:delete',\n          'user:read', 'user:write', 'user:delete', 'user:manage_roles',\n          'system:admin', 'system:logs', 'system:metrics', 'system:backup',\n          'api:batch', 'api:webhooks'\n        ],\n        hierarchyLevel: 5,\n        isSystemRole: true,\n        inheritsFrom: ['moderator'],\n      },\n    ];\n    \n    defaultRoles.forEach(role => {\n      this.roles.set(role.name, role);\n    });\n  }\n  \n  /**\n   * Add a new permission to the system\n   */\n  addPermission(permission: Permission): void {\n    if (this.permissions.has(permission.name)) {\n      throw new Error(`Permission '${permission.name}' already exists`);\n    }\n    \n    this.permissions.set(permission.name, permission);\n  }\n  \n  /**\n   * Add a new role to the system\n   */\n  addRole(role: Role): void {\n    if (this.roles.has(role.name)) {\n      throw new Error(`Role '${role.name}' already exists`);\n    }\n    \n    // Validate that all permissions in the role exist\n    for (const permissionName of role.permissions) {\n      if (!this.permissions.has(permissionName)) {\n        throw new Error(`Permission '${permissionName}' does not exist`);\n      }\n    }\n    \n    // Validate inheritance hierarchy\n    if (role.inheritsFrom) {\n      for (const parentRole of role.inheritsFrom) {\n        if (!this.roles.has(parentRole)) {\n          throw new Error(`Parent role '${parentRole}' does not exist`);\n        }\n        \n        const parent = this.roles.get(parentRole)!;\n        if (parent.hierarchyLevel >= role.hierarchyLevel) {\n          throw new Error(`Role hierarchy violation: '${role.name}' cannot inherit from '${parentRole}'`);\n        }\n      }\n    }\n    \n    this.roles.set(role.name, role);\n    \n    // Clear cache when roles change\n    this.clearRoleCache();\n  }\n  \n  /**\n   * Get all permissions for a set of roles (including inherited)\n   */\n  getEffectivePermissions(roleNames: string[]): string[] {\n    const allPermissions = new Set<string>();\n    const processedRoles = new Set<string>();\n    \n    const processRole = (roleName: string) => {\n      if (processedRoles.has(roleName)) {\n        return;\n      }\n      \n      processedRoles.add(roleName);\n      const role = this.roles.get(roleName);\n      \n      if (!role) {\n        console.warn(`Role '${roleName}' not found`);\n        return;\n      }\n      \n      // Add role's direct permissions\n      role.permissions.forEach(permission => {\n        allPermissions.add(permission);\n      });\n      \n      // Process inherited roles\n      if (role.inheritsFrom) {\n        role.inheritsFrom.forEach(parentRole => {\n          processRole(parentRole);\n        });\n      }\n    };\n    \n    roleNames.forEach(processRole);\n    \n    return Array.from(allPermissions);\n  }\n  \n  /**\n   * Check if user has a specific permission\n   */\n  hasPermission(userRoles: string[], requiredPermission: string, context?: AccessContext): AuthorizationResult {\n    const effectivePermissions = this.getEffectivePermissions(userRoles);\n    const hasBasicPermission = effectivePermissions.includes(requiredPermission);\n    \n    if (!hasBasicPermission) {\n      return {\n        allowed: false,\n        reason: 'Permission not granted',\n        requiredPermissions: [requiredPermission],\n        missingPermissions: [requiredPermission],\n      };\n    }\n    \n    // If context provided, evaluate conditions\n    if (context) {\n      const permission = this.permissions.get(requiredPermission);\n      if (permission?.conditions && permission.conditions.length > 0) {\n        const conditionResult = this.evaluateConditions(permission.conditions, context);\n        return {\n          allowed: conditionResult.allowed,\n          reason: conditionResult.allowed ? 'Permission granted with conditions' : conditionResult.reason,\n          requiredPermissions: [requiredPermission],\n          conditionsEvaluated: true,\n          additionalContext: conditionResult.context,\n        };\n      }\n    }\n    \n    return {\n      allowed: true,\n      reason: 'Permission granted',\n    };\n  }\n  \n  /**\n   * Check if user has any of the required permissions\n   */\n  hasAnyPermission(userRoles: string[], requiredPermissions: string[], context?: AccessContext): AuthorizationResult {\n    const missingPermissions: string[] = [];\n    \n    for (const permission of requiredPermissions) {\n      const result = this.hasPermission(userRoles, permission, context);\n      if (result.allowed) {\n        return {\n          allowed: true,\n          reason: `Permission '${permission}' granted`,\n          requiredPermissions,\n        };\n      }\n      \n      if (result.missingPermissions) {\n        missingPermissions.push(...result.missingPermissions);\n      }\n    }\n    \n    return {\n      allowed: false,\n      reason: 'None of the required permissions are granted',\n      requiredPermissions,\n      missingPermissions: [...new Set(missingPermissions)],\n    };\n  }\n  \n  /**\n   * Check if user has all required permissions\n   */\n  hasAllPermissions(userRoles: string[], requiredPermissions: string[], context?: AccessContext): AuthorizationResult {\n    const missingPermissions: string[] = [];\n    const allContexts: Record<string, any>[] = [];\n    \n    for (const permission of requiredPermissions) {\n      const result = this.hasPermission(userRoles, permission, context);\n      if (!result.allowed) {\n        if (result.missingPermissions) {\n          missingPermissions.push(...result.missingPermissions);\n        }\n      }\n      \n      if (result.additionalContext) {\n        allContexts.push(result.additionalContext);\n      }\n    }\n    \n    if (missingPermissions.length > 0) {\n      return {\n        allowed: false,\n        reason: 'Missing required permissions',\n        requiredPermissions,\n        missingPermissions: [...new Set(missingPermissions)],\n      };\n    }\n    \n    return {\n      allowed: true,\n      reason: 'All required permissions granted',\n      requiredPermissions,\n      additionalContext: allContexts.length > 0 ? Object.assign({}, ...allContexts) : undefined,\n    };\n  }\n  \n  /**\n   * Check if user can access a specific resource\n   */\n  canAccessResource(\n    userRoles: string[], \n    resourceType: string, \n    action: string, \n    context: AccessContext\n  ): AuthorizationResult {\n    const requiredPermission = `${resourceType}:${action}`;\n    return this.hasPermission(userRoles, requiredPermission, context);\n  }\n  \n  /**\n   * Evaluate permission conditions\n   */\n  private evaluateConditions(\n    conditions: PermissionCondition[], \n    context: AccessContext\n  ): { allowed: boolean; reason?: string; context?: Record<string, any> } {\n    const results: boolean[] = [];\n    const evaluationContext: Record<string, any> = {};\n    \n    for (const condition of conditions) {\n      const result = this.evaluateCondition(condition, context);\n      results.push(result.allowed);\n      \n      if (result.context) {\n        Object.assign(evaluationContext, result.context);\n      }\n      \n      if (!result.allowed) {\n        return {\n          allowed: false,\n          reason: result.reason || `Condition '${condition.type}' failed`,\n          context: evaluationContext,\n        };\n      }\n    }\n    \n    return {\n      allowed: results.every(r => r),\n      context: evaluationContext,\n    };\n  }\n  \n  /**\n   * Evaluate a single permission condition\n   */\n  private evaluateCondition(\n    condition: PermissionCondition, \n    context: AccessContext\n  ): { allowed: boolean; reason?: string; context?: Record<string, any> } {\n    switch (condition.type) {\n      case 'ownership':\n        return this.evaluateOwnershipCondition(condition, context);\n      \n      case 'time':\n        return this.evaluateTimeCondition(condition, context);\n      \n      case 'ip':\n        return this.evaluateIPCondition(condition, context);\n      \n      case 'resource_state':\n        return this.evaluateResourceStateCondition(condition, context);\n      \n      case 'custom':\n        return this.evaluateCustomCondition(condition, context);\n      \n      default:\n        return {\n          allowed: false,\n          reason: `Unknown condition type: ${condition.type}`,\n        };\n    }\n  }\n  \n  private evaluateOwnershipCondition(\n    condition: PermissionCondition, \n    context: AccessContext\n  ): { allowed: boolean; reason?: string; context?: Record<string, any> } {\n    if (!context.resource || !condition.field) {\n      return {\n        allowed: false,\n        reason: 'Ownership condition requires resource and field',\n      };\n    }\n    \n    const resourceValue = this.getNestedProperty(context.resource, condition.field);\n    const allowed = this.compareValues(resourceValue, condition.operator, context.userId);\n    \n    return {\n      allowed,\n      reason: allowed ? undefined : 'User does not own this resource',\n      context: { ownershipCheck: { field: condition.field, value: resourceValue } },\n    };\n  }\n  \n  private evaluateTimeCondition(\n    condition: PermissionCondition, \n    context: AccessContext\n  ): { allowed: boolean; reason?: string; context?: Record<string, any> } {\n    const currentTime = context.requestContext.timestamp;\n    const allowed = this.compareValues(currentTime, condition.operator, condition.value);\n    \n    return {\n      allowed,\n      reason: allowed ? undefined : 'Time-based restriction applies',\n      context: { timeCheck: { current: currentTime, condition: condition.value } },\n    };\n  }\n  \n  private evaluateIPCondition(\n    condition: PermissionCondition, \n    context: AccessContext\n  ): { allowed: boolean; reason?: string; context?: Record<string, any> } {\n    const clientIP = context.requestContext.ip;\n    const allowed = this.compareValues(clientIP, condition.operator, condition.value);\n    \n    return {\n      allowed,\n      reason: allowed ? undefined : 'IP-based restriction applies',\n      context: { ipCheck: { clientIP, allowedValues: condition.value } },\n    };\n  }\n  \n  private evaluateResourceStateCondition(\n    condition: PermissionCondition, \n    context: AccessContext\n  ): { allowed: boolean; reason?: string; context?: Record<string, any> } {\n    if (!context.resource || !condition.field) {\n      return {\n        allowed: false,\n        reason: 'Resource state condition requires resource and field',\n      };\n    }\n    \n    const resourceValue = this.getNestedProperty(context.resource, condition.field);\n    const allowed = this.compareValues(resourceValue, condition.operator, condition.value);\n    \n    return {\n      allowed,\n      reason: allowed ? undefined : `Resource state condition failed for ${condition.field}`,\n      context: { stateCheck: { field: condition.field, value: resourceValue, expected: condition.value } },\n    };\n  }\n  \n  private evaluateCustomCondition(\n    condition: PermissionCondition, \n    context: AccessContext\n  ): { allowed: boolean; reason?: string; context?: Record<string, any> } {\n    // Custom conditions would be implemented based on specific business logic\n    console.warn('Custom condition evaluation not implemented:', condition);\n    return {\n      allowed: true,\n      reason: 'Custom condition defaulted to allow',\n      context: { customCondition: condition },\n    };\n  }\n  \n  private compareValues(actual: any, operator: string, expected: any): boolean {\n    switch (operator) {\n      case 'equals':\n        return actual === expected;\n      \n      case 'not_equals':\n        return actual !== expected;\n      \n      case 'contains':\n        return typeof actual === 'string' && actual.includes(expected);\n      \n      case 'in':\n        return Array.isArray(expected) && expected.includes(actual);\n      \n      case 'not_in':\n        return Array.isArray(expected) && !expected.includes(actual);\n      \n      case 'greater_than':\n        return actual > expected;\n      \n      case 'less_than':\n        return actual < expected;\n      \n      case 'between':\n        return Array.isArray(expected) && expected.length === 2 && \n               actual >= expected[0] && actual <= expected[1];\n      \n      default:\n        return false;\n    }\n  }\n  \n  private getNestedProperty(obj: any, path: string): any {\n    return path.split('.').reduce((current, key) => current?.[key], obj);\n  }\n  \n  private clearRoleCache(): void {\n    this.userRoleCache.clear();\n  }\n  \n  /**\n   * Express middleware factory for RBAC authorization\n   */\n  createAuthorizationMiddleware(options: {\n    permissions?: string[];\n    requireAllPermissions?: boolean;\n    resourceExtractor?: (req: Request) => { type: string; id?: string; data?: any };\n    condition?: PermissionCondition[];\n  }) {\n    return async (req: Request & { user?: any }, res: Response, next: NextFunction) => {\n      try {\n        if (!req.user) {\n          return res.status(401).json({\n            success: false,\n            error: 'Authentication required',\n          });\n        }\n        \n        const userRoles = req.user.roles || [];\n        const permissions = options.permissions || [];\n        \n        if (permissions.length === 0) {\n          // No specific permissions required\n          return next();\n        }\n        \n        // Extract resource information if provided\n        let resource: any;\n        let resourceType: string | undefined;\n        let resourceId: string | undefined;\n        \n        if (options.resourceExtractor) {\n          const resourceInfo = options.resourceExtractor(req);\n          resourceType = resourceInfo.type;\n          resourceId = resourceInfo.id;\n          resource = resourceInfo.data;\n        }\n        \n        // Build access context\n        const context: AccessContext = {\n          userId: req.user.id,\n          userRoles,\n          userPermissions: req.user.permissions || [],\n          resource,\n          resourceId,\n          resourceType,\n          requestContext: {\n            ip: this.getClientIP(req),\n            userAgent: req.headers['user-agent'] || 'unknown',\n            timestamp: new Date(),\n            method: req.method,\n            path: req.path,\n          },\n        };\n        \n        // Check permissions\n        const authResult = options.requireAllPermissions\n          ? this.hasAllPermissions(userRoles, permissions, context)\n          : this.hasAnyPermission(userRoles, permissions, context);\n        \n        if (!authResult.allowed) {\n          return res.status(403).json({\n            success: false,\n            error: 'Insufficient permissions',\n            details: {\n              reason: authResult.reason,\n              requiredPermissions: authResult.requiredPermissions,\n              missingPermissions: authResult.missingPermissions,\n            },\n          });\n        }\n        \n        // Add authorization info to request for downstream middleware\n        (req as any).authorization = {\n          result: authResult,\n          context,\n        };\n        \n        next();\n      } catch (error) {\n        console.error('Authorization middleware error:', error);\n        res.status(500).json({\n          success: false,\n          error: 'Authorization system error',\n        });\n      }\n    };\n  }\n  \n  /**\n   * Get role hierarchy information\n   */\n  getRoleHierarchy(): Array<{ role: string; level: number; inherits: string[] }> {\n    return Array.from(this.roles.values())\n      .sort((a, b) => a.hierarchyLevel - b.hierarchyLevel)\n      .map(role => ({\n        role: role.name,\n        level: role.hierarchyLevel,\n        inherits: role.inheritsFrom || [],\n      }));\n  }\n  \n  /**\n   * Get all available permissions grouped by resource\n   */\n  getPermissionsByResource(): Record<string, Permission[]> {\n    const grouped: Record<string, Permission[]> = {};\n    \n    for (const permission of this.permissions.values()) {\n      const resource = permission.resource || 'system';\n      if (!grouped[resource]) {\n        grouped[resource] = [];\n      }\n      grouped[resource].push(permission);\n    }\n    \n    return grouped;\n  }\n  \n  /**\n   * Validate role assignment (prevent privilege escalation)\n   */\n  canAssignRole(assignerRoles: string[], targetRole: string): { allowed: boolean; reason?: string } {\n    const targetRoleData = this.roles.get(targetRole);\n    if (!targetRoleData) {\n      return { allowed: false, reason: 'Target role does not exist' };\n    }\n    \n    // Get highest hierarchy level of assigner\n    const assignerMaxLevel = Math.max(\n      ...assignerRoles.map(roleName => {\n        const role = this.roles.get(roleName);\n        return role ? role.hierarchyLevel : 0;\n      })\n    );\n    \n    // Can only assign roles at lower hierarchy level\n    if (targetRoleData.hierarchyLevel >= assignerMaxLevel) {\n      return {\n        allowed: false,\n        reason: 'Cannot assign role at same or higher hierarchy level',\n      };\n    }\n    \n    // System roles require admin permission\n    if (targetRoleData.isSystemRole) {\n      const hasAdminPermission = this.hasPermission(assignerRoles, 'system:admin').allowed;\n      if (!hasAdminPermission) {\n        return {\n          allowed: false,\n          reason: 'System admin permission required to assign system roles',\n        };\n      }\n    }\n    \n    return { allowed: true };\n  }\n  \n  private getClientIP(req: Request): string {\n    return (\n      (req.headers['x-forwarded-for'] as string) ||\n      (req.headers['x-real-ip'] as string) ||\n      req.connection.remoteAddress ||\n      req.socket.remoteAddress ||\n      'unknown'\n    ).split(',')[0].trim();\n  }\n}