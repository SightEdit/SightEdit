/**\n * Secure SightEdit Implementation Example\n * \n * This example demonstrates how to implement SightEdit with comprehensive\n * security features including JWT authentication, RBAC authorization,\n * and security best practices.\n */\n\nimport express from 'express';\nimport cors from 'cors';\nimport helmet from 'helmet';\nimport rateLimit from 'express-rate-limit';\nimport { createSecureSightEditHandler, SecureAuthSystem } from '../secure-sightedit-handler';\nimport * as crypto from 'crypto';\n\n// Environment configuration\nconst config = {\n  port: process.env.PORT || 3000,\n  nodeEnv: process.env.NODE_ENV || 'development',\n  jwtAccessSecret: process.env.JWT_ACCESS_SECRET || crypto.randomBytes(64).toString('hex'),\n  jwtRefreshSecret: process.env.JWT_REFRESH_SECRET || crypto.randomBytes(64).toString('hex'),\n  databaseUrl: process.env.DATABASE_URL,\n  smtpHost: process.env.SMTP_HOST,\n  smtpUser: process.env.SMTP_USER,\n  smtpPass: process.env.SMTP_PASS,\n};\n\n// Validate production environment\nif (config.nodeEnv === 'production') {\n  const requiredEnvVars = ['JWT_ACCESS_SECRET', 'JWT_REFRESH_SECRET'];\n  const missingVars = requiredEnvVars.filter(varName => !process.env[varName]);\n  \n  if (missingVars.length > 0) {\n    console.error(`Missing required environment variables: ${missingVars.join(', ')}`);\n    process.exit(1);\n  }\n  \n  if (config.jwtAccessSecret === config.jwtRefreshSecret) {\n    console.error('JWT access and refresh secrets must be different in production');\n    process.exit(1);\n  }\n}\n\n/**\n * Create Express application with security middleware\n */\nfunction createSecureApp(): express.Application {\n  const app = express();\n  \n  // Security middleware\n  app.use(helmet({\n    contentSecurityPolicy: {\n      directives: {\n        defaultSrc: [\"'self'\"],\n        scriptSrc: [\"'self'\"],\n        styleSrc: [\"'self'\", \"'unsafe-inline'\"], // Required for dynamic styling\n        imgSrc: [\"'self'\", 'data:', 'https:', 'blob:'],\n        connectSrc: [\"'self'\", 'wss:', 'ws:'],\n        fontSrc: [\"'self'\", 'data:'],\n        objectSrc: [\"'none'\"],\n        mediaSrc: [\"'self'\"],\n        frameSrc: [\"'none'\"],\n      },\n    },\n    hsts: {\n      maxAge: 31536000,\n      includeSubDomains: true,\n      preload: true,\n    },\n  }));\n  \n  // CORS configuration\n  app.use(cors({\n    origin: (origin, callback) => {\n      // In production, replace with your actual domains\n      const allowedOrigins = [\n        'http://localhost:3000',\n        'http://localhost:3001',\n        'https://yourdomain.com',\n        'https://admin.yourdomain.com',\n      ];\n      \n      if (!origin && config.nodeEnv === 'development') {\n        return callback(null, true);\n      }\n      \n      if (allowedOrigins.includes(origin || '')) {\n        callback(null, true);\n      } else {\n        callback(new Error('Not allowed by CORS'));\n      }\n    },\n    credentials: true,\n    methods: ['GET', 'POST', 'PUT', 'DELETE', 'OPTIONS'],\n    allowedHeaders: ['Content-Type', 'Authorization', 'X-API-Key', 'X-SightEdit-Version'],\n    maxAge: 86400, // 24 hours\n  }));\n  \n  // Rate limiting\n  const limiter = rateLimit({\n    windowMs: 15 * 60 * 1000, // 15 minutes\n    max: 100, // Limit each IP to 100 requests per windowMs\n    message: {\n      error: 'Too many requests from this IP, please try again later.',\n    },\n    standardHeaders: true,\n    legacyHeaders: false,\n    // Skip successful requests for certain endpoints\n    skip: (req) => {\n      return req.path === '/api/health' || req.path === '/api/auth/refresh';\n    },\n  });\n  \n  app.use('/api/', limiter);\n  \n  // Body parsing middleware\n  app.use(express.json({ limit: '10mb' }));\n  app.use(express.urlencoded({ extended: true, limit: '10mb' }));\n  \n  // Trust proxy if behind reverse proxy (nginx, load balancer, etc.)\n  if (config.nodeEnv === 'production') {\n    app.set('trust proxy', 1);\n  }\n  \n  return app;\n}\n\n/**\n * Initialize secure authentication system\n */\nfunction createAuthSystem(): SecureAuthSystem {\n  const authConfig = SecureAuthSystem.createSecureConfig({\n    jwt: {\n      accessTokenSecret: config.jwtAccessSecret,\n      refreshTokenSecret: config.jwtRefreshSecret,\n      accessTokenExpiry: '15m', // Short-lived for security\n      refreshTokenExpiry: '7d',\n      issuer: 'sightedit-api',\n      audience: ['sightedit-client'],\n      clockTolerance: 30,\n      enableRateLimiting: true,\n      maxLoginAttempts: 5,\n      lockoutDuration: 900, // 15 minutes\n      requireTwoFactor: config.nodeEnv === 'production', // Enable 2FA in production\n    },\n    security: {\n      maxLoginAttempts: 5,\n      lockoutDuration: 15, // minutes\n      passwordResetExpiry: 60, // 1 hour\n      emailVerificationExpiry: 24, // 24 hours\n      maxSessions: 5,\n      requireEmailVerification: config.nodeEnv === 'production',\n      enableTwoFactor: config.nodeEnv === 'production',\n      enableAccountLockout: true,\n      passwordHistory: 5,\n    },\n    // Email configuration (optional but recommended for production)\n    email: config.smtpHost ? {\n      host: config.smtpHost,\n      port: 587,\n      secure: false,\n      auth: {\n        user: config.smtpUser!,\n        pass: config.smtpPass!,\n      },\n      from: 'noreply@yourdomain.com',\n    } : undefined,\n  });\n  \n  return new SecureAuthSystem(authConfig);\n}\n\n/**\n * Custom audit logger for security events\n */\nfunction createAuditLogger() {\n  return (event: any) => {\n    // In production, send to your logging service (Datadog, Splunk, etc.)\n    const logEntry = {\n      ...event,\n      environment: config.nodeEnv,\n      service: 'sightedit-api',\n    };\n    \n    if (config.nodeEnv === 'production') {\n      // Send to production logging service\n      console.log(JSON.stringify(logEntry));\n    } else {\n      // Pretty print for development\n      console.log('\\n=== AUDIT EVENT ===');\n      console.log(`Action: ${event.action}`);\n      console.log(`Resource: ${event.resource}`);\n      console.log(`User: ${event.userEmail || 'Anonymous'}`);\n      console.log(`IP: ${event.ipAddress}`);\n      console.log(`Success: ${event.success}`);\n      if (event.error) {\n        console.log(`Error: ${event.error}`);\n      }\n      if (event.details) {\n        console.log(`Details:`, event.details);\n      }\n      console.log('==================\\n');\n    }\n  };\n}\n\n/**\n * Main application setup\n */\nasync function createApplication(): Promise<{ app: express.Application; authSystem: SecureAuthSystem }> {\n  const app = createSecureApp();\n  const authSystem = createAuthSystem();\n  const auditLogger = createAuditLogger();\n  \n  // Validate configuration\n  const validation = authSystem.validateConfiguration();\n  if (!validation.valid) {\n    console.error('Authentication system configuration errors:');\n    validation.errors.forEach(error => console.error(`  - ${error}`));\n    process.exit(1);\n  }\n  \n  if (validation.warnings.length > 0) {\n    console.warn('Authentication system configuration warnings:');\n    validation.warnings.forEach(warning => console.warn(`  - ${warning}`));\n  }\n  \n  // Create secure SightEdit handler\n  const { router } = createSecureSightEditHandler({\n    authSystem,\n    storage: config.databaseUrl ? 'database' : 'memory',\n    databaseConfig: config.databaseUrl ? {\n      url: config.databaseUrl,\n      ssl: config.nodeEnv === 'production',\n    } : undefined,\n    requireAuth: true,\n    enableAuditLog: true,\n    auditLogger,\n    maxFileSize: 10 * 1024 * 1024, // 10MB\n    allowedFileTypes: [\n      'image/jpeg',\n      'image/png', \n      'image/gif',\n      'image/webp',\n      'application/pdf',\n      'text/plain',\n    ],\n    maxBatchSize: 50,\n    cors: {\n      origin: (origin, callback) => {\n        const allowedOrigins = [\n          'http://localhost:3000',\n          'https://yourdomain.com',\n        ];\n        callback(null, !origin || allowedOrigins.includes(origin));\n      },\n      credentials: true,\n    },\n    healthCheck: {\n      enabled: true,\n      endpoint: '/health',\n      includeSystemInfo: true,\n      includeAuthStatus: true,\n      includeDependencies: true,\n    },\n  });\n  \n  // Mount SightEdit API\n  app.use('/api', router);\n  \n  // Additional custom routes\n  app.get('/', (req, res) => {\n    res.json({\n      service: 'SightEdit API',\n      version: '1.0.0',\n      environment: config.nodeEnv,\n      authentication: 'enabled',\n      security: authSystem.getSecurityStatus(),\n    });\n  });\n  \n  // Error handling middleware\n  app.use((err: Error, req: express.Request, res: express.Response, next: express.NextFunction) => {\n    console.error('Unhandled error:', err);\n    \n    auditLogger({\n      timestamp: new Date(),\n      action: 'system_error',\n      resource: 'api',\n      ipAddress: req.ip || 'unknown',\n      userAgent: req.headers['user-agent'] || 'unknown',\n      success: false,\n      error: err.message,\n      details: {\n        path: req.path,\n        method: req.method,\n        stack: config.nodeEnv === 'development' ? err.stack : undefined,\n      },\n    });\n    \n    res.status(500).json({\n      success: false,\n      error: config.nodeEnv === 'production' ? 'Internal server error' : err.message,\n    });\n  });\n  \n  // 404 handler\n  app.use((req, res) => {\n    res.status(404).json({\n      success: false,\n      error: 'Endpoint not found',\n      path: req.path,\n    });\n  });\n  \n  return { app, authSystem };\n}\n\n/**\n * Start the server\n */\nasync function startServer(): Promise<void> {\n  try {\n    const { app, authSystem } = await createApplication();\n    \n    const server = app.listen(config.port, () => {\n      console.log(`\\n🚀 SightEdit API Server Started`);\n      console.log(`   Environment: ${config.nodeEnv}`);\n      console.log(`   Port: ${config.port}`);\n      console.log(`   Authentication: Enabled`);\n      console.log(`   Security Status:`);\n      \n      const securityStatus = authSystem.getSecurityStatus();\n      console.log(`     - JWT: ${securityStatus.jwtEnabled ? '✅' : '❌'}`);\n      console.log(`     - RBAC: ${securityStatus.rbacEnabled ? '✅' : '❌'}`);\n      console.log(`     - Rate Limiting: ${securityStatus.rateLimitingEnabled ? '✅' : '❌'}`);\n      console.log(`     - Email Verification: ${securityStatus.emailVerificationEnabled ? '✅' : '❌'}`);\n      console.log(`     - Account Lockout: ${securityStatus.accountLockoutEnabled ? '✅' : '❌'}`);\n      console.log(`     - Two Factor Auth: ${securityStatus.twoFactorEnabled ? '✅' : '❌'}`);\n      \n      if (securityStatus.configuration.warnings.length > 0) {\n        console.log(`\\n⚠️  Security Warnings:`);\n        securityStatus.configuration.warnings.forEach(warning => {\n          console.log(`     - ${warning}`);\n        });\n      }\n      \n      console.log(`\\n📊 Available Endpoints:`);\n      console.log(`   - POST /api/auth/register`);\n      console.log(`   - POST /api/auth/login`);\n      console.log(`   - POST /api/auth/refresh`);\n      console.log(`   - POST /api/auth/logout`);\n      console.log(`   - GET  /api/auth/me`);\n      console.log(`   - POST /api/save`);\n      console.log(`   - POST /api/batch`);\n      console.log(`   - POST /api/upload`);\n      console.log(`   - GET  /api/schema/:sight`);\n      console.log(`   - GET  /api/health`);\n      \n      console.log(`\\n🔐 Default User Roles:`);\n      securityStatus.roleHierarchy.forEach(role => {\n        console.log(`   - ${role.role} (Level ${role.level})`);\n      });\n      \n      console.log(`\\n✨ Ready for secure editing!\\n`);\n    });\n    \n    // Graceful shutdown\n    const gracefulShutdown = (signal: string) => {\n      console.log(`\\n⚡ Received ${signal}, shutting down gracefully...`);\n      \n      server.close(() => {\n        console.log('✅ HTTP server closed.');\n        console.log('✅ SightEdit API shutdown complete.');\n        process.exit(0);\n      });\n      \n      // Force close after 30 seconds\n      setTimeout(() => {\n        console.error('❌ Could not close connections in time, forcefully shutting down');\n        process.exit(1);\n      }, 30000);\n    };\n    \n    process.on('SIGTERM', () => gracefulShutdown('SIGTERM'));\n    process.on('SIGINT', () => gracefulShutdown('SIGINT'));\n    \n  } catch (error) {\n    console.error('❌ Failed to start server:', error);\n    process.exit(1);\n  }\n}\n\n/**\n * Client usage example\n */\nexport const clientUsageExample = {\n  // Registration\n  register: async (userData: { email: string; name: string; password: string }) => {\n    const response = await fetch('/api/auth/register', {\n      method: 'POST',\n      headers: { 'Content-Type': 'application/json' },\n      body: JSON.stringify(userData),\n    });\n    \n    const data = await response.json();\n    \n    if (data.success) {\n      // Store tokens securely (httpOnly cookies recommended)\n      localStorage.setItem('accessToken', data.tokens.accessToken);\n      localStorage.setItem('refreshToken', data.tokens.refreshToken);\n    }\n    \n    return data;\n  },\n  \n  // Login\n  login: async (credentials: { email: string; password: string }) => {\n    const response = await fetch('/api/auth/login', {\n      method: 'POST',\n      headers: { 'Content-Type': 'application/json' },\n      body: JSON.stringify(credentials),\n    });\n    \n    const data = await response.json();\n    \n    if (data.success) {\n      localStorage.setItem('accessToken', data.tokens.accessToken);\n      localStorage.setItem('refreshToken', data.tokens.refreshToken);\n    }\n    \n    return data;\n  },\n  \n  // Authenticated API call\n  saveContent: async (contentData: { sight: string; value: any; type: string }) => {\n    const token = localStorage.getItem('accessToken');\n    \n    const response = await fetch('/api/save', {\n      method: 'POST',\n      headers: {\n        'Content-Type': 'application/json',\n        'Authorization': `Bearer ${token}`,\n      },\n      body: JSON.stringify(contentData),\n    });\n    \n    const data = await response.json();\n    \n    // Handle token refresh if needed\n    if (response.status === 401) {\n      const refreshed = await this.refreshToken();\n      if (refreshed) {\n        // Retry with new token\n        return this.saveContent(contentData);\n      }\n    }\n    \n    return data;\n  },\n  \n  // Token refresh\n  refreshToken: async () => {\n    const refreshToken = localStorage.getItem('refreshToken');\n    \n    const response = await fetch('/api/auth/refresh', {\n      method: 'POST',\n      headers: { 'Content-Type': 'application/json' },\n      body: JSON.stringify({ refreshToken }),\n    });\n    \n    const data = await response.json();\n    \n    if (data.success) {\n      localStorage.setItem('accessToken', data.tokens.accessToken);\n      localStorage.setItem('refreshToken', data.tokens.refreshToken);\n      return true;\n    }\n    \n    // Refresh failed, redirect to login\n    localStorage.removeItem('accessToken');\n    localStorage.removeItem('refreshToken');\n    window.location.href = '/login';\n    return false;\n  },\n};\n\n/**\n * Environment variables documentation\n */\nexport const environmentVariables = {\n  required: {\n    JWT_ACCESS_SECRET: 'Secret key for signing access tokens (minimum 64 characters)',\n    JWT_REFRESH_SECRET: 'Secret key for signing refresh tokens (minimum 64 characters)',\n  },\n  optional: {\n    PORT: 'Server port (default: 3000)',\n    NODE_ENV: 'Environment (development/production)',\n    DATABASE_URL: 'Database connection string',\n    SMTP_HOST: 'SMTP server hostname for emails',\n    SMTP_USER: 'SMTP username',\n    SMTP_PASS: 'SMTP password',\n    JWT_ACCESS_EXPIRY: 'Access token expiry (default: 15m)',\n    JWT_REFRESH_EXPIRY: 'Refresh token expiry (default: 7d)',\n    MAX_LOGIN_ATTEMPTS: 'Max failed login attempts (default: 5)',\n    LOCKOUT_DURATION: 'Account lockout duration in seconds (default: 900)',\n    REQUIRE_EMAIL_VERIFICATION: 'Require email verification (default: true in production)',\n    ENABLE_2FA: 'Enable two-factor authentication (default: true in production)',\n    HTTPS_ONLY: 'Enforce HTTPS in production (default: true)',\n  },\n};\n\n// Start server if this file is run directly\nif (require.main === module) {\n  startServer().catch(console.error);\n}\n\nexport { createApplication, createAuthSystem, startServer };