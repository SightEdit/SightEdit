import { Request, Response, NextFunction, RequestHandler, Router } from 'express';
import { SecureAuthSystem, createSecureAuth } from './auth/secure-index';
import { DatabaseConfig, createDatabaseStorage } from './storage/DatabaseStorage';
import * as path from 'path';
import * as crypto from 'crypto';
import * as fs from 'fs/promises';
import * as os from 'os';
import multer from 'multer';
import sharp from 'sharp';

export interface SecureSightEditOptions {
  // Storage options
  storage?: 'memory' | 'file' | 'database' | StorageAdapter;
  storagePath?: string;
  databaseConfig?: DatabaseConfig;
  
  // Authentication and authorization
  authSystem?: SecureAuthSystem;
  requireAuth?: boolean;
  
  // Legacy auth function (deprecated - use authSystem instead)
  auth?: (req: Request) => boolean | Promise<boolean>;
  
  // Hooks
  beforeSave?: (data: SaveData, user?: any) => SaveData | Promise<SaveData>;
  afterSave?: (data: SaveData, result: any, user?: any) => void | Promise<void>;
  
  // Security
  cors?: boolean | CorsOptions;
  rateLimit?: RateLimitOptions;
  healthCheck?: HealthCheckOptions;
  maxFileSize?: number;
  allowedFileTypes?: string[];
  maxBatchSize?: number;
  
  // Audit logging
  enableAuditLog?: boolean;
  auditLogger?: (event: AuditEvent) => void | Promise<void>;
}

export interface AuditEvent {
  timestamp: Date;
  userId?: string;
  userEmail?: string;
  action: string;
  resource: string;
  resourceId?: string;
  ipAddress: string;
  userAgent: string;
  success: boolean;
  error?: string;
  details?: Record<string, any>;
}

export interface HealthCheckOptions {
  enabled?: boolean;
  endpoint?: string;
  includeSystemInfo?: boolean;
  includeStorageInfo?: boolean;
  includeDependencies?: boolean;
  includeAuthStatus?: boolean;
  customChecks?: Array<() => Promise<HealthCheckResult>>;
}

export interface HealthCheckResult {
  name: string;
  status: 'healthy' | 'degraded' | 'unhealthy';
  message?: string;
  responseTime?: number;
  details?: Record<string, any>;
}

export interface SaveData {
  sight: string;
  value: any;
  id?: string;
  type: string;
  context?: Record<string, any>;
  timestamp?: number;
}

export interface BatchOperation {
  type: 'create' | 'update' | 'delete';
  data: SaveData;
}

export interface StorageAdapter {
  get(key: string): Promise<any>;
  set(key: string, value: any): Promise<void>;
  delete(key: string): Promise<void>;
  list(prefix?: string): Promise<string[]>;
}

export interface CorsOptions {
  origin?: string | string[] | ((origin: string) => boolean);
  credentials?: boolean;
  methods?: string[];
  allowedHeaders?: string[];
}

export interface RateLimitOptions {
  windowMs?: number;
  max?: number;
  message?: string;
}

// Enhanced storage adapters with user context
class SecureMemoryStorage implements StorageAdapter {
  private data = new Map<string, any>();
  private metadata = new Map<string, { createdBy: string; createdAt: Date; updatedAt: Date }>();

  async get(key: string): Promise<any> {
    return this.data.get(key);
  }

  async set(key: string, value: any, userId?: string): Promise<void> {
    const now = new Date();
    
    if (!this.metadata.has(key)) {
      this.metadata.set(key, {
        createdBy: userId || 'system',
        createdAt: now,
        updatedAt: now,
      });
    } else {
      const meta = this.metadata.get(key)!;
      meta.updatedAt = now;
      this.metadata.set(key, meta);
    }
    
    this.data.set(key, value);
  }

  async delete(key: string): Promise<void> {
    this.data.delete(key);
    this.metadata.delete(key);
  }

  async list(prefix?: string): Promise<string[]> {
    const keys = Array.from(this.data.keys());
    if (prefix) {
      return keys.filter(key => key.startsWith(prefix));
    }
    return keys;
  }
  
  async getMetadata(key: string): Promise<any> {
    return this.metadata.get(key);
  }
}

/**\n * Secure SightEdit handler with comprehensive authentication and authorization\n */\nexport function createSecureSightEditHandler(options: SecureSightEditOptions = {}): { router: Router; authSystem: SecureAuthSystem } {\n  const router = Router();\n  \n  // Initialize authentication system\n  let authSystem: SecureAuthSystem;\n  if (options.authSystem) {\n    authSystem = options.authSystem;\n  } else {\n    // Create default secure auth system\n    authSystem = createSecureAuth();\n  }\n  \n  // Initialize storage\n  const storage = createSecureStorage(options);\n  \n  // Initialize audit logging\n  const auditLogger = options.auditLogger || defaultAuditLogger;\n  \n  // Apply CORS if configured\n  if (options.cors) {\n    router.use((req, res, next) => {\n      applyCors(req, res, options.cors!);\n      next();\n    });\n  }\n  \n  // Apply security headers\n  router.use((req, res, next) => {\n    applySecurityHeaders(res);\n    next();\n  });\n  \n  // Handle OPTIONS requests\n  router.options('*', (req, res) => {\n    res.status(204).end();\n  });\n  \n  // Authentication routes (public)\n  const authRoutes = authSystem.getAuthRoutes();\n  router.post('/auth/register', authRoutes.register);\n  router.post('/auth/login', authRoutes.login);\n  router.post('/auth/refresh', authRoutes.refreshTokens);\n  router.post('/auth/logout', ...authSystem.requireAuth(), authRoutes.logout);\n  router.post('/auth/forgot-password', authRoutes.requestPasswordReset);\n  router.post('/auth/reset-password', authRoutes.resetPassword);\n  router.get('/auth/me', ...authSystem.requireAuth(), authRoutes.getCurrentUser);\n  \n  // Main SightEdit routes (protected)\n  \n  // Save endpoint with authentication and authorization\n  router.post('/save', \n    ...getAuthMiddleware(authSystem, options, 'content', 'write'),\n    async (req: Request & { user?: any }, res: Response) => {\n      await handleSecureSave(req, res, storage, options, auditLogger);\n    }\n  );\n  \n  // Batch endpoint with authentication and authorization\n  router.post('/batch',\n    ...getAuthMiddleware(authSystem, options, 'api', 'batch'),\n    async (req: Request & { user?: any }, res: Response) => {\n      await handleSecureBatch(req, res, storage, options, auditLogger);\n    }\n  );\n  \n  // Schema endpoint with authentication\n  router.get('/schema/:sight',\n    ...getAuthMiddleware(authSystem, options, 'schema', 'read'),\n    async (req: Request & { user?: any }, res: Response) => {\n      await handleSecureSchema(req, res, storage, options, auditLogger);\n    }\n  );\n  \n  // Upload endpoint with file validation and authentication\n  router.post('/upload',\n    ...getAuthMiddleware(authSystem, options, 'file', 'upload'),\n    async (req: Request & { user?: any }, res: Response) => {\n      await handleSecureUpload(req, res, storage, options, auditLogger);\n    }\n  );\n  \n  // Health check endpoint\n  router.get('/health', async (req, res) => {\n    await handleSecureHealthCheck(req, res, storage, authSystem, options);\n  });\n  \n  router.head('/health', async (req, res) => {\n    await handleHealthCheckHead(req, res, storage, authSystem, options);\n  });\n  \n  // System info endpoint (admin only)\n  router.get('/system/info',\n    ...authSystem.requireSystemAdmin(),\n    async (req: Request & { user?: any }, res: Response) => {\n      res.json({\n        success: true,\n        system: {\n          version: process.env.npm_package_version || '1.0.0',\n          node: process.version,\n          platform: os.platform(),\n          arch: os.arch(),\n          uptime: process.uptime(),\n          memory: process.memoryUsage(),\n          loadAvg: os.loadavg(),\n        },\n        auth: authSystem.getSecurityStatus(),\n      });\n    }\n  );\n  \n  // Emergency lockdown endpoint (admin only)\n  router.post('/system/lockdown',\n    ...authSystem.requireSystemAdmin(),\n    async (req: Request & { user?: any }, res: Response) => {\n      const result = authSystem.emergencyLockdown();\n      \n      await auditLogger({\n        timestamp: new Date(),\n        userId: req.user?.id,\n        userEmail: req.user?.email,\n        action: 'emergency_lockdown',\n        resource: 'system',\n        ipAddress: getClientIP(req),\n        userAgent: req.headers['user-agent'] || 'unknown',\n        success: result.success,\n        details: { reason: 'manual_activation' },\n      });\n      \n      res.json({\n        success: result.success,\n        message: result.message,\n      });\n    }\n  );\n  \n  return { router, authSystem };\n}\n\n/**\n * Get appropriate authentication middleware based on configuration\n */\nfunction getAuthMiddleware(\n  authSystem: SecureAuthSystem,\n  options: SecureSightEditOptions,\n  resourceType?: string,\n  action?: string\n): RequestHandler[] {\n  // If authentication is explicitly disabled\n  if (options.requireAuth === false) {\n    return [];\n  }\n  \n  // If legacy auth function is provided, use it\n  if (options.auth && !options.authSystem) {\n    return [createLegacyAuthWrapper(options.auth)];\n  }\n  \n  // Use secure auth system with resource-level permissions\n  if (resourceType && action) {\n    return authSystem.requireResourceAccess(resourceType, action);\n  }\n  \n  // Default to basic authentication\n  return authSystem.requireAuth();\n}\n\n/**\n * Legacy auth function wrapper for backward compatibility\n */\nfunction createLegacyAuthWrapper(authFn: (req: Request) => boolean | Promise<boolean>): RequestHandler {\n  return async (req: Request, res: Response, next: NextFunction) => {\n    try {\n      const isAuthorized = await authFn(req);\n      if (!isAuthorized) {\n        return res.status(401).json({\n          success: false,\n          error: 'Unauthorized',\n        });\n      }\n      next();\n    } catch (error) {\n      console.error('Legacy auth error:', error);\n      res.status(500).json({\n        success: false,\n        error: 'Authentication error',\n      });\n    }\n  };\n}\n\n/**\n * Secure save handler with user context and audit logging\n */\nasync function handleSecureSave(\n  req: Request & { user?: any },\n  res: Response,\n  storage: StorageAdapter,\n  options: SecureSightEditOptions,\n  auditLogger: (event: AuditEvent) => void | Promise<void>\n): Promise<void> {\n  const user = req.user;\n  const startTime = Date.now();\n  \n  try {\n    let data: SaveData = req.body;\n    \n    // Input validation\n    if (!data || typeof data !== 'object') {\n      await auditLogger(createAuditEvent(req, 'save', 'content', false, 'Invalid request body'));\n      return res.status(400).json({\n        success: false,\n        error: 'Invalid request body',\n      });\n    }\n    \n    if (!data.sight || typeof data.sight !== 'string' || data.value === undefined) {\n      await auditLogger(createAuditEvent(req, 'save', 'content', false, 'Missing required fields'));\n      return res.status(400).json({\n        success: false,\n        error: 'Missing required fields: sight and value',\n      });\n    }\n    \n    // Validate sight identifier format\n    if (!isValidSightIdentifier(data.sight)) {\n      await auditLogger(createAuditEvent(req, 'save', 'content', false, 'Invalid sight identifier'));\n      return res.status(400).json({\n        success: false,\n        error: 'Invalid sight identifier format',\n      });\n    }\n    \n    // Sanitize input data\n    data = sanitizeInputData(data);\n    \n    // Apply beforeSave hook\n    if (options.beforeSave) {\n      data = await options.beforeSave(data, user);\n    }\n    \n    // Add user context\n    data.timestamp = Date.now();\n    \n    // Generate key and save\n    const key = generateSecureKey(data, user);\n    \n    if (storage instanceof SecureMemoryStorage) {\n      await storage.set(key, data, user?.id);\n    } else {\n      await storage.set(key, data);\n    }\n    \n    // Apply afterSave hook\n    if (options.afterSave) {\n      await options.afterSave(data, { key }, user);\n    }\n    \n    // Log successful save\n    await auditLogger(createAuditEvent(req, 'save', 'content', true, undefined, {\n      sight: data.sight,\n      type: data.type,\n      responseTime: Date.now() - startTime,\n    }));\n    \n    res.json({\n      success: true,\n      data: data.value,\n      version: data.timestamp,\n    });\n    \n  } catch (error) {\n    const errorMessage = error instanceof Error ? error.message : 'Unknown error';\n    \n    await auditLogger(createAuditEvent(req, 'save', 'content', false, errorMessage, {\n      responseTime: Date.now() - startTime,\n    }));\n    \n    console.error('Secure save error:', error);\n    res.status(500).json({\n      success: false,\n      error: 'Save operation failed',\n    });\n  }\n}\n\n/**\n * Secure batch handler with operation limits and validation\n */\nasync function handleSecureBatch(\n  req: Request & { user?: any },\n  res: Response,\n  storage: StorageAdapter,\n  options: SecureSightEditOptions,\n  auditLogger: (event: AuditEvent) => void | Promise<void>\n): Promise<void> {\n  const user = req.user;\n  const startTime = Date.now();\n  \n  try {\n    const { operations } = req.body;\n    \n    if (!Array.isArray(operations)) {\n      await auditLogger(createAuditEvent(req, 'batch', 'api', false, 'Operations must be an array'));\n      return res.status(400).json({\n        success: false,\n        error: 'Operations must be an array',\n      });\n    }\n    \n    // Check batch size limit\n    const maxBatchSize = options.maxBatchSize || 100;\n    if (operations.length > maxBatchSize) {\n      await auditLogger(createAuditEvent(req, 'batch', 'api', false, `Batch size exceeds limit: ${operations.length}`));\n      return res.status(400).json({\n        success: false,\n        error: `Batch size exceeds maximum of ${maxBatchSize} operations`,\n      });\n    }\n    \n    const results = [];\n    const processedOperations = [];\n    \n    for (const operation of operations) {\n      try {\n        // Validate operation\n        if (!operation.type || !['create', 'update', 'delete'].includes(operation.type)) {\n          results.push({ success: false, error: 'Invalid operation type' });\n          continue;\n        }\n        \n        if (!operation.data || typeof operation.data !== 'object') {\n          results.push({ success: false, error: 'Invalid operation data' });\n          continue;\n        }\n        \n        // Sanitize operation data\n        const sanitizedData = sanitizeInputData(operation.data);\n        const key = generateSecureKey(sanitizedData, user);\n        \n        switch (operation.type) {\n          case 'create':\n          case 'update':\n            sanitizedData.timestamp = Date.now();\n            \n            if (storage instanceof SecureMemoryStorage) {\n              await storage.set(key, sanitizedData, user?.id);\n            } else {\n              await storage.set(key, sanitizedData);\n            }\n            \n            results.push({ success: true });\n            processedOperations.push({ type: operation.type, sight: sanitizedData.sight });\n            break;\n            \n          case 'delete':\n            await storage.delete(key);\n            results.push({ success: true });\n            processedOperations.push({ type: operation.type, sight: sanitizedData.sight });\n            break;\n        }\n        \n      } catch (error) {\n        results.push({ success: false, error: String(error) });\n      }\n    }\n    \n    // Log successful batch operation\n    await auditLogger(createAuditEvent(req, 'batch', 'api', true, undefined, {\n      operationCount: operations.length,\n      successCount: results.filter(r => r.success).length,\n      failureCount: results.filter(r => !r.success).length,\n      operations: processedOperations,\n      responseTime: Date.now() - startTime,\n    }));\n    \n    res.json({\n      success: true,\n      results,\n    });\n    \n  } catch (error) {\n    const errorMessage = error instanceof Error ? error.message : 'Unknown error';\n    \n    await auditLogger(createAuditEvent(req, 'batch', 'api', false, errorMessage, {\n      responseTime: Date.now() - startTime,\n    }));\n    \n    console.error('Secure batch error:', error);\n    res.status(500).json({\n      success: false,\n      error: 'Batch operation failed',\n    });\n  }\n}\n\n/**\n * Secure schema handler\n */\nasync function handleSecureSchema(\n  req: Request & { user?: any },\n  res: Response,\n  storage: StorageAdapter,\n  options: SecureSightEditOptions,\n  auditLogger: (event: AuditEvent) => void | Promise<void>\n): Promise<void> {\n  const startTime = Date.now();\n  \n  try {\n    const sight = extractSightFromPath(req.path || req.url || '');\n    \n    if (!sight || !isValidSightIdentifier(sight)) {\n      await auditLogger(createAuditEvent(req, 'schema_read', 'schema', false, 'Invalid sight identifier'));\n      return res.status(400).json({\n        success: false,\n        error: 'Invalid sight identifier',\n      });\n    }\n    \n    // Try to get stored schema\n    const schemaKey = `_schema:${sight}`;\n    const storedSchema = await storage.get(schemaKey);\n    \n    // Log schema access\n    await auditLogger(createAuditEvent(req, 'schema_read', 'schema', true, undefined, {\n      sight,\n      hasCustomSchema: !!storedSchema,\n      responseTime: Date.now() - startTime,\n    }));\n    \n    if (storedSchema) {\n      res.json(storedSchema);\n      return;\n    }\n    \n    // Return default schema\n    res.json({\n      type: 'text',\n      label: sight,\n      placeholder: `Enter ${sight}`,\n    });\n    \n  } catch (error) {\n    const errorMessage = error instanceof Error ? error.message : 'Unknown error';\n    \n    await auditLogger(createAuditEvent(req, 'schema_read', 'schema', false, errorMessage, {\n      responseTime: Date.now() - startTime,\n    }));\n    \n    console.error('Secure schema error:', error);\n    res.status(500).json({\n      success: false,\n      error: 'Failed to retrieve schema',\n    });\n  }\n}\n\n/**\n * Secure file upload handler\n */\nasync function handleSecureUpload(\n  req: Request & { user?: any },\n  res: Response,\n  storage: StorageAdapter,\n  options: SecureSightEditOptions,\n  auditLogger: (event: AuditEvent) => void | Promise<void>\n): Promise<void> {\n  const maxFileSize = options.maxFileSize || 10 * 1024 * 1024; // 10MB default\n  const allowedTypes = options.allowedFileTypes || [\n    'image/jpeg', 'image/png', 'image/gif', 'image/webp'\n  ];\n  \n  const uploadMulter = multer({\n    storage: multer.memoryStorage(),\n    limits: {\n      fileSize: maxFileSize,\n      files: 5, // Max 5 files per request\n    },\n    fileFilter: (req, file, cb) => {\n      if (allowedTypes.includes(file.mimetype)) {\n        cb(null, true);\n      } else {\n        cb(new Error(`File type ${file.mimetype} not allowed`));\n      }\n    },\n  });\n  \n  uploadMulter.array('files', 5)(req, res, async (err) => {\n    const startTime = Date.now();\n    \n    if (err) {\n      const errorMessage = err.message || 'Upload failed';\n      \n      await auditLogger(createAuditEvent(req, 'upload', 'file', false, errorMessage, {\n        responseTime: Date.now() - startTime,\n      }));\n      \n      if (err instanceof multer.MulterError) {\n        if (err.code === 'LIMIT_FILE_SIZE') {\n          return res.status(413).json({\n            success: false,\n            error: `File too large. Maximum size is ${Math.round(maxFileSize / (1024 * 1024))}MB`,\n          });\n        }\n      }\n      \n      return res.status(400).json({\n        success: false,\n        error: errorMessage,\n      });\n    }\n    \n    try {\n      const files = req.files as Express.Multer.File[];\n      const user = req.user;\n      \n      if (!files || files.length === 0) {\n        await auditLogger(createAuditEvent(req, 'upload', 'file', false, 'No files uploaded'));\n        return res.status(400).json({\n          success: false,\n          error: 'No files uploaded',\n        });\n      }\n      \n      const uploadResults = [];\n      const uploadDir = options.storagePath || './uploads';\n      \n      // Ensure upload directory exists\n      await fs.mkdir(uploadDir, { recursive: true });\n      \n      for (const file of files) {\n        try {\n          // Additional security validation\n          if (!await validateFileContent(file.buffer, file.mimetype)) {\n            uploadResults.push({\n              success: false,\n              originalName: file.originalname,\n              error: 'File validation failed',\n            });\n            continue;\n          }\n          \n          // Generate secure filename\n          const timestamp = Date.now();\n          const random = crypto.randomBytes(16).toString('hex');\n          const extension = path.extname(file.originalname).toLowerCase();\n          const filename = `${timestamp}-${random}${extension}`;\n          const filepath = path.join(uploadDir, filename);\n          \n          // Process file based on type\n          if (file.mimetype.startsWith('image/')) {\n            const processedBuffer = await processImageSecurely(file.buffer, file.mimetype);\n            await fs.writeFile(filepath, processedBuffer);\n            \n            // Generate metadata\n            const metadata = await sharp(processedBuffer).metadata();\n            \n            uploadResults.push({\n              success: true,\n              originalName: file.originalname,\n              filename: filename,\n              url: `/uploads/${filename}`,\n              mimetype: file.mimetype,\n              size: processedBuffer.length,\n              width: metadata.width,\n              height: metadata.height,\n            });\n          } else {\n            await fs.writeFile(filepath, file.buffer);\n            \n            uploadResults.push({\n              success: true,\n              originalName: file.originalname,\n              filename: filename,\n              url: `/uploads/${filename}`,\n              mimetype: file.mimetype,\n              size: file.size,\n            });\n          }\n          \n          // Store file metadata\n          const fileKey = `file:${filename}`;\n          const fileMetadata = {\n            originalName: file.originalname,\n            filename: filename,\n            mimetype: file.mimetype,\n            size: file.size,\n            uploadedAt: new Date().toISOString(),\n            uploadedBy: user?.id || 'anonymous',\n            uploadedByEmail: user?.email,\n          };\n          \n          if (storage instanceof SecureMemoryStorage) {\n            await storage.set(fileKey, fileMetadata, user?.id);\n          } else {\n            await storage.set(fileKey, fileMetadata);\n          }\n          \n        } catch (fileError) {\n          uploadResults.push({\n            success: false,\n            originalName: file.originalname,\n            error: `Processing failed: ${fileError}`,\n          });\n        }\n      }\n      \n      // Log upload operation\n      await auditLogger(createAuditEvent(req, 'upload', 'file', true, undefined, {\n        fileCount: files.length,\n        successCount: uploadResults.filter(r => r.success).length,\n        failureCount: uploadResults.filter(r => !r.success).length,\n        totalSize: files.reduce((sum, f) => sum + f.size, 0),\n        responseTime: Date.now() - startTime,\n      }));\n      \n      res.json({\n        success: true,\n        files: uploadResults,\n      });\n      \n    } catch (error) {\n      const errorMessage = error instanceof Error ? error.message : 'Unknown error';\n      \n      await auditLogger(createAuditEvent(req, 'upload', 'file', false, errorMessage, {\n        responseTime: Date.now() - startTime,\n      }));\n      \n      console.error('Secure upload error:', error);\n      res.status(500).json({\n        success: false,\n        error: 'Upload processing failed',\n      });\n    }\n  });\n}\n\n/**\n * Enhanced health check with authentication system status\n */\nasync function handleSecureHealthCheck(\n  req: Request,\n  res: Response,\n  storage: StorageAdapter,\n  authSystem: SecureAuthSystem,\n  options: SecureSightEditOptions\n): Promise<void> {\n  const healthOptions = options.healthCheck || { enabled: true };\n  \n  if (healthOptions.enabled === false) {\n    return res.status(404).json({ error: 'Health check disabled' });\n  }\n  \n  const startTime = Date.now();\n  const checks: HealthCheckResult[] = [];\n  let overallStatus: 'healthy' | 'degraded' | 'unhealthy' = 'healthy';\n  \n  try {\n    // Storage health check\n    const storageCheck = await checkStorageHealth(storage);\n    checks.push(storageCheck);\n    if (storageCheck.status !== 'healthy') {\n      overallStatus = storageCheck.status === 'unhealthy' ? 'unhealthy' : 'degraded';\n    }\n    \n    // Authentication system health check\n    if (healthOptions.includeAuthStatus) {\n      const authCheck = checkAuthSystemHealth(authSystem);\n      checks.push(authCheck);\n      if (authCheck.status !== 'healthy' && overallStatus === 'healthy') {\n        overallStatus = authCheck.status;\n      }\n    }\n    \n    // System health checks\n    if (healthOptions.includeSystemInfo) {\n      const memoryCheck = checkMemoryHealth();\n      checks.push(memoryCheck);\n      \n      const cpuCheck = checkCPUHealth();\n      checks.push(cpuCheck);\n      \n      if ((memoryCheck.status !== 'healthy' || cpuCheck.status !== 'healthy') && overallStatus === 'healthy') {\n        overallStatus = 'degraded';\n      }\n    }\n    \n    // Custom health checks\n    if (healthOptions.customChecks) {\n      for (const customCheck of healthOptions.customChecks) {\n        try {\n          const result = await customCheck();\n          checks.push(result);\n          if (result.status !== 'healthy' && overallStatus === 'healthy') {\n            overallStatus = result.status;\n          }\n        } catch (error) {\n          checks.push({\n            name: 'custom_check',\n            status: 'unhealthy',\n            message: `Custom check failed: ${error}`,\n          });\n          overallStatus = 'unhealthy';\n        }\n      }\n    }\n    \n    const responseTime = Date.now() - startTime;\n    \n    const healthData = {\n      status: overallStatus,\n      timestamp: new Date().toISOString(),\n      uptime: process.uptime() * 1000,\n      version: process.env.npm_package_version || '1.0.0',\n      environment: process.env.NODE_ENV || 'development',\n      responseTime,\n      checks,\n    };\n    \n    const httpStatus = overallStatus === 'healthy' ? 200 : \n                      overallStatus === 'degraded' ? 200 : 503;\n    \n    res.status(httpStatus).json(healthData);\n    \n  } catch (error) {\n    res.status(503).json({\n      status: 'unhealthy',\n      timestamp: new Date().toISOString(),\n      error: 'Health check failed',\n      message: error instanceof Error ? error.message : 'Unknown error',\n    });\n  }\n}\n\n// Helper functions\n\nfunction createSecureStorage(options: SecureSightEditOptions): StorageAdapter {\n  if (typeof options.storage === 'object' && options.storage !== null) {\n    return options.storage;\n  }\n  \n  switch (options.storage) {\n    case 'file':\n      // Enhanced file storage would be implemented here\n      return new SecureMemoryStorage();\n    case 'database':\n      if (!options.databaseConfig) {\n        throw new Error('Database storage requires databaseConfig option');\n      }\n      return createDatabaseStorage(options.databaseConfig);\n    case 'memory':\n    default:\n      return new SecureMemoryStorage();\n  }\n}\n\nfunction generateSecureKey(data: SaveData, user?: any): string {\n  const parts = [data.sight];\n  \n  if (data.context?.recordId) {\n    parts.push(data.context.recordId);\n  }\n  \n  if (data.id) {\n    parts.push(data.id);\n  }\n  \n  // Add user context for isolation\n  if (user?.id) {\n    parts.push(`user:${user.id}`);\n  }\n  \n  return parts.join(':');\n}\n\nfunction createAuditEvent(\n  req: Request & { user?: any },\n  action: string,\n  resource: string,\n  success: boolean,\n  error?: string,\n  details?: Record<string, any>\n): AuditEvent {\n  return {\n    timestamp: new Date(),\n    userId: req.user?.id,\n    userEmail: req.user?.email,\n    action,\n    resource,\n    ipAddress: getClientIP(req),\n    userAgent: req.headers['user-agent'] || 'unknown',\n    success,\n    error,\n    details,\n  };\n}\n\nfunction defaultAuditLogger(event: AuditEvent): void {\n  const logLevel = event.success ? 'info' : 'warn';\n  console.log(`[${logLevel.toUpperCase()}] AUDIT:`, JSON.stringify(event));\n}\n\nfunction getClientIP(req: Request): string {\n  return (\n    (req.headers['x-forwarded-for'] as string) ||\n    (req.headers['x-real-ip'] as string) ||\n    req.connection.remoteAddress ||\n    req.socket.remoteAddress ||\n    'unknown'\n  ).split(',')[0].trim();\n}\n\nfunction isValidSightIdentifier(sight: string): boolean {\n  if (!sight || typeof sight !== 'string') {\n    return false;\n  }\n  \n  if (sight.length === 0 || sight.length > 100) {\n    return false;\n  }\n  \n  const validPattern = /^[a-zA-Z0-9_.-]+$/;\n  if (!validPattern.test(sight)) {\n    return false;\n  }\n  \n  if (sight.includes('..') || sight.includes('/') || sight.includes('\\\\')) {\n    return false;\n  }\n  \n  return true;\n}\n\nfunction sanitizeInputData(data: SaveData): SaveData {\n  const sanitized: SaveData = {\n    sight: data.sight.trim(),\n    value: sanitizeValue(data.value),\n    type: data.type || 'text',\n    timestamp: data.timestamp,\n  };\n  \n  if (data.id) {\n    sanitized.id = data.id.trim();\n  }\n  \n  if (data.context && typeof data.context === 'object') {\n    sanitized.context = sanitizeContext(data.context);\n  }\n  \n  return sanitized;\n}\n\nfunction sanitizeValue(value: any): any {\n  if (value === null || value === undefined) {\n    return value;\n  }\n  \n  if (typeof value === 'string') {\n    return value\n      .replace(/<script[^>]*>.*?<\\/script>/gis, '')\n      .replace(/javascript:/gi, '')\n      .replace(/vbscript:/gi, '')\n      .replace(/on\\w+\\s*=/gi, '');\n  }\n  \n  if (Array.isArray(value)) {\n    return value.map(item => sanitizeValue(item));\n  }\n  \n  if (typeof value === 'object') {\n    const sanitized: any = {};\n    for (const [key, val] of Object.entries(value)) {\n      const cleanKey = key.replace(/[^a-zA-Z0-9_-]/g, '_');\n      if (cleanKey.length > 0 && cleanKey.length <= 50) {\n        sanitized[cleanKey] = sanitizeValue(val);\n      }\n    }\n    return sanitized;\n  }\n  \n  return value;\n}\n\nfunction sanitizeContext(context: Record<string, any>): Record<string, any> {\n  const sanitized: Record<string, any> = {};\n  \n  for (const [key, value] of Object.entries(context)) {\n    const cleanKey = key.replace(/[^a-zA-Z0-9_-]/g, '_');\n    if (cleanKey.length > 0 && cleanKey.length <= 50) {\n      sanitized[cleanKey] = sanitizeValue(value);\n    }\n  }\n  \n  return sanitized;\n}\n\nfunction extractSightFromPath(urlPath: string): string | null {\n  if (!urlPath || typeof urlPath !== 'string') {\n    return null;\n  }\n  \n  const cleanPath = urlPath.split('?')[0].split('#')[0];\n  const match = cleanPath.match(/^\\/schema\\/([^/]+)$/);\n  \n  if (!match) {\n    return null;\n  }\n  \n  const sight = decodeURIComponent(match[1]);\n  \n  if (sight.length > 100) {\n    return null;\n  }\n  \n  return sight;\n}\n\nasync function validateFileContent(buffer: Buffer, mimetype: string): Promise<boolean> {\n  // Basic file type validation using magic numbers\n  const fileSignatures: Record<string, Buffer[]> = {\n    'image/jpeg': [Buffer.from([0xFF, 0xD8, 0xFF])],\n    'image/png': [Buffer.from([0x89, 0x50, 0x4E, 0x47])],\n    'image/gif': [Buffer.from([0x47, 0x49, 0x46, 0x38])],\n    'image/webp': [Buffer.from([0x52, 0x49, 0x46, 0x46])],\n  };\n  \n  const signatures = fileSignatures[mimetype];\n  if (!signatures) {\n    return true; // Allow if no signature defined\n  }\n  \n  return signatures.some(signature => buffer.subarray(0, signature.length).equals(signature));\n}\n\nasync function processImageSecurely(buffer: Buffer, mimetype: string): Promise<Buffer> {\n  let processor = sharp(buffer);\n  \n  // Remove EXIF data for privacy\n  processor = processor.rotate(); // Auto-rotate and remove EXIF\n  \n  // Limit dimensions for security\n  const metadata = await processor.metadata();\n  if (metadata.width && metadata.height) {\n    const maxDimension = Math.max(metadata.width, metadata.height);\n    if (maxDimension > 4000) {\n      const scale = 4000 / maxDimension;\n      processor = processor.resize(\n        Math.round(metadata.width * scale),\n        Math.round(metadata.height * scale),\n        { fit: 'inside', withoutEnlargement: true }\n      );\n    }\n  }\n  \n  // Optimize based on format\n  switch (mimetype) {\n    case 'image/jpeg':\n      processor = processor.jpeg({ quality: 85, progressive: true });\n      break;\n    case 'image/png':\n      processor = processor.png({ quality: 85, compressionLevel: 9 });\n      break;\n    case 'image/webp':\n      processor = processor.webp({ quality: 85 });\n      break;\n    default:\n      processor = processor.jpeg({ quality: 85 });\n  }\n  \n  return processor.toBuffer();\n}\n\nfunction applyCors(req: Request, res: Response, cors: boolean | CorsOptions): void {\n  if (cors === true) {\n    res.header('Access-Control-Allow-Origin', '*');\n    res.header('Access-Control-Allow-Methods', 'GET, POST, PUT, DELETE, OPTIONS');\n    res.header('Access-Control-Allow-Headers', 'Content-Type, Authorization, X-API-Key, X-SightEdit-Version');\n    res.header('Access-Control-Allow-Credentials', 'true');\n  } else if (typeof cors === 'object') {\n    const origin = req.headers.origin;\n    \n    if (cors.origin) {\n      if (typeof cors.origin === 'string') {\n        res.header('Access-Control-Allow-Origin', cors.origin);\n      } else if (Array.isArray(cors.origin) && origin && cors.origin.includes(origin)) {\n        res.header('Access-Control-Allow-Origin', origin);\n      } else if (typeof cors.origin === 'function' && origin && cors.origin(origin)) {\n        res.header('Access-Control-Allow-Origin', origin);\n      }\n    }\n    \n    if (cors.methods) {\n      res.header('Access-Control-Allow-Methods', cors.methods.join(', '));\n    }\n    \n    if (cors.allowedHeaders) {\n      res.header('Access-Control-Allow-Headers', cors.allowedHeaders.join(', '));\n    }\n    \n    if (cors.credentials) {\n      res.header('Access-Control-Allow-Credentials', 'true');\n    }\n  }\n}\n\nfunction applySecurityHeaders(res: Response): void {\n  res.setHeader('X-Content-Type-Options', 'nosniff');\n  res.setHeader('X-Frame-Options', 'DENY');\n  res.setHeader('X-XSS-Protection', '1; mode=block');\n  res.setHeader('Referrer-Policy', 'strict-origin-when-cross-origin');\n  res.setHeader('Permissions-Policy', 'geolocation=(), microphone=(), camera=()');\n  \n  if (process.env.NODE_ENV === 'production') {\n    res.setHeader('Strict-Transport-Security', 'max-age=31536000; includeSubDomains; preload');\n  }\n  \n  // Enhanced CSP for SightEdit\n  const cspDirectives = [\n    \"default-src 'self'\",\n    \"script-src 'self'\", // Removed unsafe-inline for better security\n    \"style-src 'self' 'unsafe-inline'\", // Keep for dynamic styling\n    \"img-src 'self' data: https: blob:\",\n    \"connect-src 'self' wss: ws:\",\n    \"font-src 'self' data:\",\n    \"object-src 'none'\",\n    \"base-uri 'self'\",\n    \"frame-ancestors 'none'\",\n    \"form-action 'self'\",\n    \"upgrade-insecure-requests\"\n  ];\n  \n  res.setHeader('Content-Security-Policy', cspDirectives.join('; '));\n}\n\n// Health check functions\nasync function checkStorageHealth(storage: StorageAdapter): Promise<HealthCheckResult> {\n  const startTime = Date.now();\n  \n  try {\n    const testKey = `_health_check_${Date.now()}`;\n    const testValue = { timestamp: Date.now(), test: true };\n    \n    await storage.set(testKey, testValue);\n    const retrieved = await storage.get(testKey);\n    await storage.delete(testKey);\n    \n    const responseTime = Date.now() - startTime;\n    \n    if (!retrieved || retrieved.timestamp !== testValue.timestamp) {\n      return {\n        name: 'storage',\n        status: 'unhealthy',\n        message: 'Data integrity check failed',\n        responseTime,\n      };\n    }\n    \n    const status = responseTime > 1000 ? 'degraded' : 'healthy';\n    \n    return {\n      name: 'storage',\n      status,\n      message: `Storage operations completed in ${responseTime}ms`,\n      responseTime,\n    };\n    \n  } catch (error) {\n    return {\n      name: 'storage',\n      status: 'unhealthy',\n      message: `Storage check failed: ${error}`,\n      responseTime: Date.now() - startTime,\n    };\n  }\n}\n\nfunction checkAuthSystemHealth(authSystem: SecureAuthSystem): HealthCheckResult {\n  const startTime = Date.now();\n  \n  try {\n    const securityStatus = authSystem.getSecurityStatus();\n    const responseTime = Date.now() - startTime;\n    \n    if (!securityStatus.initialized) {\n      return {\n        name: 'auth_system',\n        status: 'unhealthy',\n        message: 'Authentication system not initialized',\n        responseTime,\n      };\n    }\n    \n    if (!securityStatus.configuration.valid) {\n      return {\n        name: 'auth_system',\n        status: 'degraded',\n        message: `Configuration issues: ${securityStatus.configuration.errors.join(', ')}`,\n        responseTime,\n        details: {\n          errors: securityStatus.configuration.errors,\n          warnings: securityStatus.configuration.warnings,\n        },\n      };\n    }\n    \n    return {\n      name: 'auth_system',\n      status: 'healthy',\n      message: 'Authentication system operational',\n      responseTime,\n      details: {\n        jwtEnabled: securityStatus.jwtEnabled,\n        rbacEnabled: securityStatus.rbacEnabled,\n        rateLimitingEnabled: securityStatus.rateLimitingEnabled,\n      },\n    };\n    \n  } catch (error) {\n    return {\n      name: 'auth_system',\n      status: 'unhealthy',\n      message: `Auth system check failed: ${error}`,\n      responseTime: Date.now() - startTime,\n    };\n  }\n}\n\nfunction checkMemoryHealth(): HealthCheckResult {\n  const memUsage = process.memoryUsage();\n  const totalMemory = os.totalmem();\n  const freeMemory = os.freemem();\n  const usedMemoryPercent = ((totalMemory - freeMemory) / totalMemory) * 100;\n  const heapUsedPercent = (memUsage.heapUsed / memUsage.heapTotal) * 100;\n  \n  let status: 'healthy' | 'degraded' | 'unhealthy' = 'healthy';\n  let message = `Memory usage: ${Math.round(heapUsedPercent)}% heap, ${Math.round(usedMemoryPercent)}% system`;\n  \n  if (heapUsedPercent > 90 || usedMemoryPercent > 95) {\n    status = 'unhealthy';\n    message = `Critical memory usage: ${Math.round(heapUsedPercent)}% heap, ${Math.round(usedMemoryPercent)}% system`;\n  } else if (heapUsedPercent > 80 || usedMemoryPercent > 85) {\n    status = 'degraded';\n    message = `High memory usage: ${Math.round(heapUsedPercent)}% heap, ${Math.round(usedMemoryPercent)}% system`;\n  }\n  \n  return {\n    name: 'memory',\n    status,\n    message,\n    details: {\n      heapUsed: memUsage.heapUsed,\n      heapTotal: memUsage.heapTotal,\n      heapUsedPercent: Math.round(heapUsedPercent),\n      systemUsedPercent: Math.round(usedMemoryPercent),\n    },\n  };\n}\n\nfunction checkCPUHealth(): HealthCheckResult {\n  const loadAvg = os.loadavg();\n  const cpuCount = os.cpus().length;\n  const load1min = loadAvg[0];\n  const loadPercent = (load1min / cpuCount) * 100;\n  \n  let status: 'healthy' | 'degraded' | 'unhealthy' = 'healthy';\n  let message = `CPU load: ${Math.round(loadPercent)}% (${load1min.toFixed(2)}/${cpuCount})`;\n  \n  if (loadPercent > 90) {\n    status = 'unhealthy';\n    message = `Critical CPU load: ${Math.round(loadPercent)}% (${load1min.toFixed(2)}/${cpuCount})`;\n  } else if (loadPercent > 70) {\n    status = 'degraded';\n    message = `High CPU load: ${Math.round(loadPercent)}% (${load1min.toFixed(2)}/${cpuCount})`;\n  }\n  \n  return {\n    name: 'cpu',\n    status,\n    message,\n    details: {\n      loadAverage1min: load1min,\n      loadPercent: Math.round(loadPercent),\n      cpuCount,\n    },\n  };\n}\n\nasync function handleHealthCheckHead(\n  req: Request,\n  res: Response,\n  storage: StorageAdapter,\n  authSystem: SecureAuthSystem,\n  options: SecureSightEditOptions\n): Promise<void> {\n  const healthOptions = options.healthCheck || { enabled: true };\n  \n  if (healthOptions.enabled === false) {\n    return res.status(404).end();\n  }\n  \n  try {\n    const startTime = Date.now();\n    const storageHealthy = await quickStorageCheck(storage);\n    const responseTime = Date.now() - startTime;\n    \n    res.status(storageHealthy ? 200 : 503)\n       .header('X-Health-Status', storageHealthy ? 'healthy' : 'unhealthy')\n       .header('X-Response-Time', responseTime.toString())\n       .end();\n  } catch (error) {\n    res.status(503).end();\n  }\n}\n\nasync function quickStorageCheck(storage: StorageAdapter): Promise<boolean> {\n  try {\n    await storage.list();\n    return true;\n  } catch (error) {\n    return false;\n  }\n}\n\n// Export the main handler for backward compatibility\nexport const sightEditHandler = createSecureSightEditHandler;