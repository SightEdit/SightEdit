import request from 'supertest';
import express from 'express';
import { SecureAuthSystem, createSecureAuth } from '../auth/secure-index';
import { createSecureSightEditHandler } from '../secure-sightedit-handler';
import * as crypto from 'crypto';

describe('Secure Authentication Integration Tests', () => {
  let app: express.Application;
  let authSystem: SecureAuthSystem;
  let server: any;
  
  beforeAll(async () => {
    // Create secure configuration for testing
    const config = SecureAuthSystem.createSecureConfig({
      jwt: {
        accessTokenSecret: crypto.randomBytes(64).toString('hex'),
        refreshTokenSecret: crypto.randomBytes(64).toString('hex'),
        accessTokenExpiry: '5m',
        refreshTokenExpiry: '1h',
      },
      security: {
        requireEmailVerification: false, // Disable for testing
        enableAccountLockout: true,
        maxLoginAttempts: 3,
        lockoutDuration: 1, // 1 minute for testing
      },
    });
    
    authSystem = new SecureAuthSystem(config);
    
    // Create Express app with secure handler\n    app = express();\n    app.use(express.json());\n    app.use(express.urlencoded({ extended: true }));\n    \n    const { router } = createSecureSightEditHandler({\n      authSystem,\n      storage: 'memory',\n      requireAuth: true,\n      enableAuditLog: true,\n    });\n    \n    app.use('/api', router);\n    \n    server = app.listen(0); // Random port\n  });\n  \n  afterAll((done) => {\n    server.close(done);\n  });\n  \n  describe('Authentication Security Tests', () => {\n    describe('Registration Security', () => {\n      it('should require strong passwords', async () => {\n        const weakPasswords = [\n          '12345678',\n          'password',\n          'abcdefgh',\n          'Password',\n          'Password1',\n        ];\n        \n        for (const password of weakPasswords) {\n          const response = await request(app)\n            .post('/api/auth/register')\n            .send({\n              email: 'test@example.com',\n              name: 'Test User',\n              password,\n            });\n          \n          expect(response.status).toBe(400);\n          expect(response.body.success).toBe(false);\n          expect(response.body.details).toEqual(\n            expect.arrayContaining([\n              expect.stringMatching(/password/i)\n            ])\n          );\n        }\n      });\n      \n      it('should accept strong passwords', async () => {\n        const response = await request(app)\n          .post('/api/auth/register')\n          .send({\n            email: 'secure@example.com',\n            name: 'Secure User',\n            password: 'SecurePass123!@#',\n          });\n        \n        expect(response.status).toBe(201);\n        expect(response.body.success).toBe(true);\n        expect(response.body.tokens).toBeDefined();\n        expect(response.body.tokens.accessToken).toBeDefined();\n        expect(response.body.tokens.refreshToken).toBeDefined();\n      });\n      \n      it('should prevent duplicate registrations', async () => {\n        const userData = {\n          email: 'duplicate@example.com',\n          name: 'Duplicate User',\n          password: 'SecurePass123!@#',\n        };\n        \n        // First registration\n        const firstResponse = await request(app)\n          .post('/api/auth/register')\n          .send(userData);\n        \n        expect(firstResponse.status).toBe(201);\n        \n        // Second registration (duplicate)\n        const secondResponse = await request(app)\n          .post('/api/auth/register')\n          .send(userData);\n        \n        expect(secondResponse.status).toBe(400);\n        expect(secondResponse.body.success).toBe(false);\n        // Should not reveal that user exists\n        expect(secondResponse.body.error).toBe('Registration failed. Please try with different details.');\n      });\n      \n      it('should validate email format', async () => {\n        const invalidEmails = [\n          'invalid-email',\n          '@example.com',\n          'test@',\n          'test..test@example.com',\n        ];\n        \n        for (const email of invalidEmails) {\n          const response = await request(app)\n            .post('/api/auth/register')\n            .send({\n              email,\n              name: 'Test User',\n              password: 'SecurePass123!@#',\n            });\n          \n          expect(response.status).toBe(400);\n          expect(response.body.success).toBe(false);\n        }\n      });\n    });\n    \n    describe('Login Security', () => {\n      const validUser = {\n        email: 'logintest@example.com',\n        name: 'Login Test',\n        password: 'SecurePass123!@#',\n      };\n      \n      beforeEach(async () => {\n        // Register test user\n        await request(app)\n          .post('/api/auth/register')\n          .send(validUser);\n      });\n      \n      it('should authenticate valid credentials', async () => {\n        const response = await request(app)\n          .post('/api/auth/login')\n          .send({\n            email: validUser.email,\n            password: validUser.password,\n          });\n        \n        expect(response.status).toBe(200);\n        expect(response.body.success).toBe(true);\n        expect(response.body.tokens).toBeDefined();\n        expect(response.body.user).toBeDefined();\n        expect(response.body.user.email).toBe(validUser.email);\n        expect(response.body.user.password).toBeUndefined(); // Password should not be returned\n      });\n      \n      it('should reject invalid credentials', async () => {\n        const response = await request(app)\n          .post('/api/auth/login')\n          .send({\n            email: validUser.email,\n            password: 'WrongPassword123!@#',\n          });\n        \n        expect(response.status).toBe(401);\n        expect(response.body.success).toBe(false);\n        expect(response.body.error).toBe('Invalid credentials.');\n      });\n      \n      it('should implement account lockout after failed attempts', async () => {\n        const maxAttempts = 3;\n        \n        // Make failed login attempts\n        for (let i = 0; i < maxAttempts; i++) {\n          const response = await request(app)\n            .post('/api/auth/login')\n            .send({\n              email: validUser.email,\n              password: 'WrongPassword',\n            });\n          \n          expect(response.status).toBe(401);\n        }\n        \n        // Next attempt should be locked\n        const lockedResponse = await request(app)\n          .post('/api/auth/login')\n          .send({\n            email: validUser.email,\n            password: validUser.password, // Even correct password\n          });\n        \n        expect(lockedResponse.status).toBe(423);\n        expect(lockedResponse.body.error).toMatch(/locked/i);\n      });\n      \n      it('should prevent user enumeration through timing attacks', async () => {\n        const nonExistentEmail = 'nonexistent@example.com';\n        \n        const startTime = Date.now();\n        const response1 = await request(app)\n          .post('/api/auth/login')\n          .send({\n            email: nonExistentEmail,\n            password: 'AnyPassword123!@#',\n          });\n        const time1 = Date.now() - startTime;\n        \n        const startTime2 = Date.now();\n        const response2 = await request(app)\n          .post('/api/auth/login')\n          .send({\n            email: validUser.email,\n            password: 'WrongPassword123!@#',\n          });\n        const time2 = Date.now() - startTime2;\n        \n        // Both should return 401\n        expect(response1.status).toBe(401);\n        expect(response2.status).toBe(401);\n        \n        // Response times should be similar (within 50ms)\n        expect(Math.abs(time1 - time2)).toBeLessThan(50);\n      });\n    });\n    \n    describe('JWT Token Security', () => {\n      let accessToken: string;\n      let refreshToken: string;\n      \n      beforeEach(async () => {\n        // Register and login to get tokens\n        await request(app)\n          .post('/api/auth/register')\n          .send({\n            email: 'tokentest@example.com',\n            name: 'Token Test',\n            password: 'SecurePass123!@#',\n          });\n        \n        const loginResponse = await request(app)\n          .post('/api/auth/login')\n          .send({\n            email: 'tokentest@example.com',\n            password: 'SecurePass123!@#',\n          });\n        \n        accessToken = loginResponse.body.tokens.accessToken;\n        refreshToken = loginResponse.body.tokens.refreshToken;\n      });\n      \n      it('should reject invalid tokens', async () => {\n        const invalidTokens = [\n          'invalid.token.here',\n          'eyJhbGciOiJub25lIiwidHlwIjoiSldUIn0.eyJzdWIiOiJhZG1pbiJ9.', // None algorithm\n          accessToken.substring(0, -10) + 'tampered123', // Tampered token\n        ];\n        \n        for (const token of invalidTokens) {\n          const response = await request(app)\n            .get('/api/auth/me')\n            .set('Authorization', `Bearer ${token}`);\n          \n          expect(response.status).toBe(401);\n          expect(response.body.success).toBe(false);\n        }\n      });\n      \n      it('should accept valid tokens', async () => {\n        const response = await request(app)\n          .get('/api/auth/me')\n          .set('Authorization', `Bearer ${accessToken}`);\n        \n        expect(response.status).toBe(200);\n        expect(response.body.success).toBe(true);\n        expect(response.body.user).toBeDefined();\n      });\n      \n      it('should refresh tokens securely', async () => {\n        const response = await request(app)\n          .post('/api/auth/refresh')\n          .send({ refreshToken });\n        \n        expect(response.status).toBe(200);\n        expect(response.body.success).toBe(true);\n        expect(response.body.tokens).toBeDefined();\n        expect(response.body.tokens.accessToken).toBeDefined();\n        expect(response.body.tokens.refreshToken).toBeDefined();\n        \n        // New tokens should be different\n        expect(response.body.tokens.accessToken).not.toBe(accessToken);\n        expect(response.body.tokens.refreshToken).not.toBe(refreshToken);\n      });\n      \n      it('should revoke tokens on logout', async () => {\n        // Logout\n        const logoutResponse = await request(app)\n          .post('/api/auth/logout')\n          .set('Authorization', `Bearer ${accessToken}`)\n          .send({ refreshToken });\n        \n        expect(logoutResponse.status).toBe(200);\n        \n        // Token should no longer work\n        const meResponse = await request(app)\n          .get('/api/auth/me')\n          .set('Authorization', `Bearer ${accessToken}`);\n        \n        expect(meResponse.status).toBe(401);\n        \n        // Refresh token should also not work\n        const refreshResponse = await request(app)\n          .post('/api/auth/refresh')\n          .send({ refreshToken });\n        \n        expect(refreshResponse.status).toBe(401);\n      });\n    });\n  });\n  \n  describe('Authorization Tests', () => {\n    let adminToken: string;\n    let userToken: string;\n    \n    beforeAll(async () => {\n      // Register admin user\n      const adminRegister = await request(app)\n        .post('/api/auth/register')\n        .send({\n          email: 'admin@example.com',\n          name: 'Admin User',\n          password: 'AdminPass123!@#',\n          roles: ['admin'],\n        });\n      \n      adminToken = adminRegister.body.tokens.accessToken;\n      \n      // Register regular user\n      const userRegister = await request(app)\n        .post('/api/auth/register')\n        .send({\n          email: 'user@example.com',\n          name: 'Regular User',\n          password: 'UserPass123!@#',\n        });\n      \n      userToken = userRegister.body.tokens.accessToken;\n    });\n    \n    it('should allow authenticated users to save content', async () => {\n      const saveData = {\n        sight: 'test-content',\n        value: 'Test content value',\n        type: 'text',\n      };\n      \n      const response = await request(app)\n        .post('/api/save')\n        .set('Authorization', `Bearer ${userToken}`)\n        .send(saveData);\n      \n      expect(response.status).toBe(200);\n      expect(response.body.success).toBe(true);\n    });\n    \n    it('should reject unauthenticated save requests', async () => {\n      const saveData = {\n        sight: 'test-content',\n        value: 'Test content value',\n        type: 'text',\n      };\n      \n      const response = await request(app)\n        .post('/api/save')\n        .send(saveData);\n      \n      expect(response.status).toBe(401);\n      expect(response.body.success).toBe(false);\n    });\n    \n    it('should allow batch operations for authenticated users', async () => {\n      const batchData = {\n        operations: [\n          {\n            type: 'create',\n            data: {\n              sight: 'batch-test-1',\n              value: 'Batch test value 1',\n              type: 'text',\n            },\n          },\n          {\n            type: 'update',\n            data: {\n              sight: 'batch-test-2',\n              value: 'Batch test value 2',\n              type: 'text',\n            },\n          },\n        ],\n      };\n      \n      const response = await request(app)\n        .post('/api/batch')\n        .set('Authorization', `Bearer ${userToken}`)\n        .send(batchData);\n      \n      expect(response.status).toBe(200);\n      expect(response.body.success).toBe(true);\n      expect(response.body.results).toHaveLength(2);\n      expect(response.body.results.every((r: any) => r.success)).toBe(true);\n    });\n    \n    it('should restrict system admin endpoints to admins only', async () => {\n      // User should not access system info\n      const userResponse = await request(app)\n        .get('/api/system/info')\n        .set('Authorization', `Bearer ${userToken}`);\n      \n      expect(userResponse.status).toBe(403);\n      \n      // Admin should access system info\n      const adminResponse = await request(app)\n        .get('/api/system/info')\n        .set('Authorization', `Bearer ${adminToken}`);\n      \n      expect(adminResponse.status).toBe(200);\n      expect(adminResponse.body.system).toBeDefined();\n      expect(adminResponse.body.auth).toBeDefined();\n    });\n    \n    it('should validate batch operation limits', async () => {\n      const largeOperations = Array.from({ length: 150 }, (_, i) => ({\n        type: 'create',\n        data: {\n          sight: `large-batch-${i}`,\n          value: `Value ${i}`,\n          type: 'text',\n        },\n      }));\n      \n      const response = await request(app)\n        .post('/api/batch')\n        .set('Authorization', `Bearer ${userToken}`)\n        .send({ operations: largeOperations });\n      \n      expect(response.status).toBe(400);\n      expect(response.body.error).toMatch(/batch size exceeds/i);\n    });\n  });\n  \n  describe('Input Validation Security', () => {\n    let userToken: string;\n    \n    beforeAll(async () => {\n      const register = await request(app)\n        .post('/api/auth/register')\n        .send({\n          email: 'validator@example.com',\n          name: 'Validation User',\n          password: 'ValidPass123!@#',\n        });\n      \n      userToken = register.body.tokens.accessToken;\n    });\n    \n    it('should sanitize XSS attempts', async () => {\n      const xssPayloads = [\n        '<script>alert(\"xss\")</script>',\n        'javascript:alert(\"xss\")',\n        '<img src=\"x\" onerror=\"alert(1)\">',\n        '<svg onload=\"alert(1)\">',\n      ];\n      \n      for (const payload of xssPayloads) {\n        const response = await request(app)\n          .post('/api/save')\n          .set('Authorization', `Bearer ${userToken}`)\n          .send({\n            sight: 'xss-test',\n            value: payload,\n            type: 'text',\n          });\n        \n        expect(response.status).toBe(200);\n        // Value should be sanitized\n        expect(response.body.data).not.toContain('<script>');\n        expect(response.body.data).not.toContain('javascript:');\n        expect(response.body.data).not.toContain('onerror=');\n        expect(response.body.data).not.toContain('onload=');\n      }\n    });\n    \n    it('should reject invalid sight identifiers', async () => {\n      const invalidSights = [\n        '../../../etc/passwd',\n        'test..test',\n        'test/path',\n        'test\\\\path',\n        'a'.repeat(200), // Too long\n        '', // Empty\n        null,\n        undefined,\n      ];\n      \n      for (const sight of invalidSights) {\n        const response = await request(app)\n          .post('/api/save')\n          .set('Authorization', `Bearer ${userToken}`)\n          .send({\n            sight,\n            value: 'test value',\n            type: 'text',\n          });\n        \n        expect(response.status).toBe(400);\n        expect(response.body.error).toMatch(/sight|identifier|format|required/i);\n      }\n    });\n    \n    it('should validate required fields', async () => {\n      const invalidPayloads = [\n        { sight: 'test' }, // Missing value\n        { value: 'test' }, // Missing sight\n        {}, // Missing both\n        null, // Null payload\n        'string', // String instead of object\n      ];\n      \n      for (const payload of invalidPayloads) {\n        const response = await request(app)\n          .post('/api/save')\n          .set('Authorization', `Bearer ${userToken}`)\n          .send(payload);\n        \n        expect(response.status).toBe(400);\n        expect(response.body.success).toBe(false);\n      }\n    });\n  });\n  \n  describe('Rate Limiting Tests', () => {\n    it('should rate limit login attempts', async () => {\n      const loginData = {\n        email: 'ratetest@example.com',\n        password: 'WrongPassword123!@#',\n      };\n      \n      const maxAttempts = 5; // Default rate limit\n      const responses: request.Response[] = [];\n      \n      // Make multiple rapid requests\n      for (let i = 0; i < maxAttempts + 2; i++) {\n        const response = await request(app)\n          .post('/api/auth/login')\n          .send(loginData);\n        \n        responses.push(response);\n      }\n      \n      // Last few requests should be rate limited\n      const rateLimitedResponses = responses.slice(-2);\n      rateLimitedResponses.forEach(response => {\n        expect([401, 429]).toContain(response.status);\n      });\n      \n      // At least one should be 429 (rate limited)\n      expect(rateLimitedResponses.some(r => r.status === 429)).toBe(true);\n    });\n  });\n  \n  describe('Health Check Security', () => {\n    it('should provide health status without authentication', async () => {\n      const response = await request(app)\n        .get('/api/health');\n      \n      expect(response.status).toBe(200);\n      expect(response.body.status).toBeDefined();\n      expect(response.body.checks).toBeDefined();\n      expect(response.body.timestamp).toBeDefined();\n      \n      // Should not expose sensitive information\n      expect(response.body.env).toBeUndefined();\n      expect(response.body.secrets).toBeUndefined();\n    });\n    \n    it('should respond to HEAD requests for monitoring', async () => {\n      const response = await request(app)\n        .head('/api/health');\n      \n      expect([200, 503]).toContain(response.status);\n      expect(response.headers['x-health-status']).toBeDefined();\n    });\n  });\n  \n  describe('Password Reset Security', () => {\n    beforeEach(async () => {\n      // Register test user\n      await request(app)\n        .post('/api/auth/register')\n        .send({\n          email: 'resettest@example.com',\n          name: 'Reset Test',\n          password: 'OldPassword123!@#',\n        });\n    });\n    \n    it('should not reveal whether email exists', async () => {\n      const existingEmail = 'resettest@example.com';\n      const nonExistentEmail = 'nonexistent@example.com';\n      \n      const response1 = await request(app)\n        .post('/api/auth/forgot-password')\n        .send({ email: existingEmail });\n      \n      const response2 = await request(app)\n        .post('/api/auth/forgot-password')\n        .send({ email: nonExistentEmail });\n      \n      // Both should return the same response to prevent email enumeration\n      expect(response1.status).toBe(200);\n      expect(response2.status).toBe(200);\n      expect(response1.body.message).toBe(response2.body.message);\n      expect(response1.body.message).toMatch(/if an account.*exists/i);\n    });\n    \n    it('should validate email format for password reset', async () => {\n      const invalidEmails = [\n        'invalid-email',\n        '@example.com',\n        'test@',\n      ];\n      \n      for (const email of invalidEmails) {\n        const response = await request(app)\n          .post('/api/auth/forgot-password')\n          .send({ email });\n        \n        expect(response.status).toBe(400);\n        expect(response.body.error).toMatch(/email/i);\n      }\n    });\n    \n    it('should require strong password for reset', async () => {\n      const response = await request(app)\n        .post('/api/auth/reset-password')\n        .send({\n          token: 'dummy-token',\n          newPassword: 'weakpass',\n        });\n      \n      // Should fail due to weak password (before even checking token)\n      expect([400, 500]).toContain(response.status);\n    });\n  });\n});\n\n// Additional security utility tests\ndescribe('Security Utilities', () => {\n  it('should generate cryptographically secure random values', () => {\n    const random1 = crypto.randomBytes(32).toString('hex');\n    const random2 = crypto.randomBytes(32).toString('hex');\n    \n    expect(random1).toHaveLength(64); // 32 bytes * 2 chars per byte\n    expect(random2).toHaveLength(64);\n    expect(random1).not.toBe(random2);\n    expect(random1).toMatch(/^[a-f0-9]{64}$/);\n  });\n  \n  it('should validate JWT configuration', () => {\n    expect(() => {\n      SecureAuthSystem.createSecureConfig({\n        jwt: {\n          accessTokenSecret: 'short', // Too short\n          refreshTokenSecret: crypto.randomBytes(64).toString('hex'),\n        },\n      });\n    }).toThrow(/access token secret.*64 characters/i);\n    \n    expect(() => {\n      const secret = crypto.randomBytes(64).toString('hex');\n      SecureAuthSystem.createSecureConfig({\n        jwt: {\n          accessTokenSecret: secret,\n          refreshTokenSecret: secret, // Same as access token\n        },\n      });\n    }).toThrow(/secrets must be different/i);\n  });\n});